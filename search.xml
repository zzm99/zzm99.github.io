<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http协议知识整理]]></title>
    <url>%2F2019%2F05%2F04%2Fhttp%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP 协议1.HTTP协议是什么？http协议是一个应用层的协议。规定了浏览器和服务器之间的通信规范。通常用TCP连接方式。 2.HTTP 1.0、1.1 连接的方式。 在HTTP 1.0 中，浏览器和服务器使用的是短连接，响应完，立即断开。 请求的过程：3次握手，请求，响应，断开连接。 http不保存连接，好处：服务器可以处理更多的连接，但是每次建立连接会降低处理速度。 现在主流的版本是HTTP 1.1 ，在HTTP 1.1 中我们使用长连接，一个请求结束后，不断开，继续请求。 3.HTTP协议的URLURL的格式： http://host[&quot;:&quot;port][abs_path] host: 代表主机域名或IP地址 port: 端口号，缺省端口80 abs_path : 请求资源的URL，如果没有，填 “/“，通常浏览器会帮我们自动完成。 EG: 1、输入：www.cnblogs.com 浏览器自动转换成：http://www.cnblogs.com/ 4.HTTP请求4.1 请求报文格式： HTTP的请求由3部分组成：请求行、请求头、请求体。 SP代表空格、CRLF代表换行 浏览器必须以这个格式发送请求，服务器才能正常解析和响应。 4.2 请求报文示例 4.3 请求方法GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据，常用于提交表单。 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 get和post是最常用的方法，简单来说，前者用于获取数据，后者用于提交数据。 5.HTTP响应5.1 响应报文格式：HTTP的响应也是由3个部分组成：响应行、响应头，响应体 响应行：status code 表示响应的状态码，description是描述信息。 同样 SP代表空格、CRLF代表换行， 响应必须以这种规范格式发送给浏览器，浏览器才能正常解析并显示。 5.2 响应报文示例 5.3响应码200段是成功；300段需要对请求做进一步的处理；400段表示客户端请求错误；500段是服务器的错误 常见响应码： “200” : OK “302” : Found 重定向. “400” : Bad Request 错误请求，发出错误的不符合Http协议的请求 “403” : Forbidden 禁止 “404” : Not Found 未找到。演示访问一个不存在的页面看报文 “500” : Internal Server Error 服务器内部错误。演示页面抛出异常。 “503” : Service Unavailable。一般是访问人数过多。 PS:会在文章的末尾为大家提供一份HTTP状态码大全的文档。 6.HTTP消息报头HTTP消息报头分4类：普通报头、请求报头、响应报头、实体报头 每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 6.1 普通报头应用于所有请求和响应消息且和请求体与响应体无关的信息就存放在普通报头中。 Cache-Control: no-cache （用于指示请求或响应消息不能缓存） Date 普通报头域表示消息产生的日期和时间 Connection: close/keep-alive （是否开启长连接） 6.2 请求报头客户端向服务器端传递请求的附加信息以及客户端自身的信息存放在请求报头 常用的请求报头： Accept: text/html,application/xhtml+xml,application/xml; 指定客户端接受哪些类型的信息。 Accept-Charset: iso-8859-1,gb2312 客户端接受的字符集 （缺省是任何字符集都可以接受。） Accept-Encoding: gzip,deflate,sdch 可接受的内容编码。 (缺省是各种内容编码都可以接受。) Accept-Language: zh-CN,zh 指定语言。（缺省各种语言都可以接受。） Authorization 用于证明客户端有权查看某个资源 Host: www.cnblogs.com 被请求资源的Internet主机和端口号 （缺省端口号：80） 这个报头是必需的 User-Agent: Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) 操作系统、浏览器和其它属性 6.3 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头： Location 响应报头域用于重定向接受者到一个新的位置 Server：Apache-Coyote/1.1 服务器信息 6.4 实体报头请求和响应消息都可以传送一个实体。 常用的实体报头： Content-Encoding: gzip 内容编码 Content-Language: zh-CN 语言 Content-Length: 10 实体正文的长度 Content-Type: text/html;charset=GB2312 返回数据的类型 Last-Modified 实体报头域用于指示资源的最后修改日期和时间。 Expires：Thu，15 Sep 2006 16:23:12 GMT 响应过期的日期和时间。]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>http协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http协议基础知识]]></title>
    <url>%2F2019%2F05%2F04%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP 简介HTTP 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 以下图表展示了HTTP协议通信流程： HTTP信息结构HTTP 消息结构HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。 一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。 服务器响应消息HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 实例下面实例是一点典型的使用GET来传递数据的实例： 客户端请求： GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应: HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: “34aa387-d-1568eb00”Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain 输出结果：Hello World! My payload includes a trailing CRLF. HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。 另一版本： GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP响应头信息HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 在本章节中我们将具体来介绍HTTP响应头信息。 应答头————说明 Allow：服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires：应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 HTTP状态码HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误 HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-typeContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>http协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-79-Word Search]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-79%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] Given word = “ABCCED”, return true.Given word = “SEE”, return true.Given word = “ABCB”, return false. Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*’ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) dfs+回溯：1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = '*'; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-55-Jump Game]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-55%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2: Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 思路1：暴力没什么好说的，特别慢。用一个数组表示i位置是否可以达到，然后遍历数组，将所有可以达到的位置置1. 12345678910bool canJump(vector&lt;int&gt;&amp; nums) &#123; //暴力 特别慢 int sz = nums.size(); vector&lt;int&gt; jus(sz, 0); jus[0] = 1; for (int i = 0; i &lt; sz; ++i) if(jus[i]) for (int j = i + 1; j &lt;= i + nums[i] &amp;&amp; j &lt; sz; ++j) jus[j] = 1; return jus[sz - 1];&#125; 思路2：动态规划dp[i]表示前面跳到第i位置时最远还可以多跳多少。可以得到递推式：dp[i]=max( dp[i - 1], nums[i - 1] )dp[i]&lt;0表示不能跳到该位置，直接返回false.时间复杂度O(N),但空间复杂度也是O(N) 123456789101112#define MAX(A,B) (A&gt;(B)?A:B)bool canJump(vector&lt;int&gt;&amp; nums) &#123; //动态规划 8ms 99% 空间O(N) int sz = nums.size(); vector&lt;bool&gt; dp(sz, 0); for (int i = 1; i &lt; sz; ++i) &#123; dp[i] = MAX(nums[i - 1], dp[i - 1]) - 1; if (dp[i] &lt; 0) return false; &#125; return dp[sz - 1] &gt;= 0;&#125; 思路3：贪心法使用一个数reach表示目前可以达到的最远距离，当reach &gt;= sz - 1时表示可以达到最后一个位置。这个方法时间复杂度仍然是O(N)，但空间复杂度仅仅是O(1) 12345678910bool canJump(vector&lt;int&gt;&amp; nums) &#123;//贪心8ms 99% 空间O(1) int sz = nums.size(), reach = 0; for (int i = 0; i &lt; sz; ++i) &#123; if (reach &lt; i || reach &gt;= sz - 1) break; if (reach &lt; nums[i] + i) reach = nums[i] + i; &#125; return reach &gt;= sz - 1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-142-Linked List Cycle II]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-142%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Follow up:Can you solve it without using extra space? 复杂度O(n^2)的方法，使用两个指针a, b。a从表头开始一步一步往前走，遇到null则说明没有环，返回false；a每走一步，b从头开始走，如果遇到b==a.next，则说明有环true，如果遇到b==a，则说明暂时没有环，继续循环。 复杂度O(n)的方法，使用两个指针slow,fast。两个指针都从表头开始走，slow每次走一步，fast每次走两步，如果fast遇到null，则说明没有环，返回false；如果slow==fast，说明有环，并且此时fast超了slow一圈，返回true。 环的长度是多少？ 如何找到环中第一个节点（即Linked List Cycle II）？ 如何将有环的链表变成单链表（解除环）？ 如何判断两个单链表是否有交点？如何找到第一个相交的节点？ 设：链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c，如图所示。环的长度是L。slow和fast的速度分别是qs,qf。下面我们来挨个问题分析。方法一：第一次相遇后，让slow,fast继续走，记录到下次相遇时循环了几次。因为当fast第二次到达Z点时，fast走了一圈，slow走了半圈，而当fast第三次到达Z点时，fast走了两圈，slow走了一圈，正好还在Z点相遇。方法二：第一次相遇后，让fast停着不走了，slow继续走，记录到下次相遇时循环了几次。方法三：第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。 我们发现L=b+c=a+b，也就是说， 从一开始到二者第一次相遇，循环的次数就等于环的长度。 我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。 在上一个问题的最后，将c段中Y点之前的那个节点与Y的链接切断即可。 如何判断两个单链表是否有交点？先判断两个链表是否有环，如果一个有环一个没环，肯定不相交；如果两个都没有环，判断两个列表的尾部是否相等；如果两个都有环，判断一个链表上的Z点是否在另一个链表上。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; struct ListNode *fast = head; struct ListNode *slow = head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast==slow) break; &#125; if(fast==slow&amp;&amp;fast-&gt;next!=NULL) &#123; slow = head; while(slow!=fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Linked-List</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-739-Daily Temperatures]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-739%2F</url>
    <content type="text"><![CDATA[Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. 因为我们所要找的是距离最近的较大的，因此，我们从后往前，依次将索引加入到stack中，不同点在于，只要遍历到比当前栈顶元素大的，就将栈顶元素从栈中删除——因为此时栈顶元素已经不是后面的元素所距离的最近的一个，较大的元素了。因此，栈顶的元素所保存的，一直都是目前来说，索引值最小的当前最大元素的索引。因此，利用这种办法，直接从后往前就可以分别对这些距离进行计算了。 从后往前，如果当前i对应的元素大于stack的top那么就pop掉这个top，一直循环，最后stack要么为空，要么不为空，为空，则为0，不为空则为top对应的i-top减去当前iWhen i = 7, stack = [7 (73)]. ans[i] = 0.When i = 6, stack = [6 (76)]. ans[i] = 0.When i = 5, stack = [5 (72), 6 (76)]. ans[i] = 1.When i = 4, stack = [4 (69), 5 (72), 6 (76)]. ans[i] = 1.When i = 3, stack = [3 (71), 5 (72), 6 (76)]. ans[i] = 2.When i = 2, stack = [2 (75), 6 (76)]. ans[i] = 4.When i = 1, stack = [1 (74), 2 (75), 6 (76)]. ans[i] = 1.When i = 0, stack = [0 (73), 1 (74), 2 (75), 6 (76)]. ans[i] = 1. 如果对于这类，到当前元素最近XX等的问题，利用栈的先进后出的性质来进行求解是一种比较可取的办法。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; res (n, 0); stack&lt;int&gt; s; for(int i = n-1;i&gt;=0;i--) &#123; while(!s.empty() &amp;&amp; temperatures[i] &gt;= temperatures[s.top()]) s.pop(); if(!s.empty()) res[i] = s.top() - i; s.push(i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Stack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-221-Maximal Square]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-221%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.Example: Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Output: 4 To apply DP, we define the state as the maximal size (square = size * size) of the square that can be formed till point (i, j), denoted as dp[i][j]. For the topmost row (i = 0) and the leftmost column (j = 0), we have dp[i][j] = matrix[i][j] - ‘0’, meaning that it can at most form a square of size 1 when the matrix has a ‘1’ in that cell. When i &gt; 0 and j &gt; 0, if matrix[i][j] = ‘0’, then dp[i][j] = 0 since no square will be able to contain the ‘0’ at that cell. If matrix[i][j] = ‘1’, we will have dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1, which means that the square will be limited by its left, upper and upper-left neighbors. dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1: 约束该点最大方形面积的三个因素： 左边延申的距离， 上面延申的距离， 左上延申的距离（对角线） 123456789101112131415161718192021 class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; dp[i][j] = matrix[i][j] - '0'; &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; sz = max(dp[i][j], sz); &#125; &#125; return sz * sz; &#125;&#125;; In the above code, it uses O(mn) space. Actually each time when we update dp[i][j], we only need dp[i-1][j-1], dp[i-1][j] (the previous row) and dp[i][j-1] (the current row). So we may just keep two rows. 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;int&gt; pre(n, 0), cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); &#125; fill(pre.begin(), pre.end(), 0); swap(pre, cur); &#125; return sz * sz; &#125;&#125;; Furthermore, we may only use just one vector 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0, pre; vector&lt;int&gt; cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int temp = cur[j]; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); pre = temp; &#125; &#125; return sz * sz; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode-236%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the binary tree.Accepted 我们在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，我们可以用递归来实现，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 1）若p和q要么分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。 2）若p和q同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。 3）若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if( root == nullptr or root == p or root == q ) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor( root-&gt;left, p, q ); TreeNode* right = lowestCommonAncestor( root-&gt;right, p, q ); if( left == nullptr ) &#123; return right; &#125; if( right == nullptr ) &#123; return left; &#125; return root; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pytorch库实现动图线性回归]]></title>
    <url>%2F2019%2F05%2F03%2Fpython%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92gif%2F</url>
    <content type="text"><![CDATA[python代码：1234567891011121314151617181920212223242526272829303132333435363738import torchimport torch.nn as nnimport matplotlib.pyplot as pltimport imageiotorch.manual_seed(0)num_samples = 100x_train = torch.linspace(0, 1, num_samples)y_train = 0.1 * x_train + 0.2 + torch.randn(num_samples)*0.03w = torch.randn(1, requires_grad=True)b = torch.randn(1, requires_grad=True)criterion = nn.MSELoss()optimizer = torch.optim.SGD([w,b], lr=0.01)images = []num_epochs = 4000for epoch in range(num_epochs): y_pred = w * x_train + b loss = criterion(y_pred, y_train) optimizer.zero_grad() loss.backward() if epoch % 100 == 99: plt.figure() plt.ylim(torch.min(y_train).item(), torch.max(y_train).item()) plt.scatter(x_train.tolist(), y_train.tolist(), marker='.') plt.plot(x_train.tolist(), y_pred.tolist(), color='r', linewidth=2) plt.title('Epoch [&#123;&#125;/&#123;&#125;], Loss: &#123;:.6f&#125;, \n Weight: &#123;:.6f&#125;, Bias: &#123;:.6f&#125;' .format(epoch+1, num_epochs, loss.item(), w.item(), b.item())) plt.savefig('a.png') plt.close() images.append(imageio.imread('a.png')) optimizer.step() imageio.mimsave('gen.gif', images, duration=0.5) 效果图：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PyTorch库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用PIL库进行gif图的解析或合成]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create1%2F</url>
    <content type="text"><![CDATA[那个星夜越过千年而我绕过半个地球重新来寻那个你那个亮尽我的眼的你一颗流星划过坠入无边黑暗你等我一千年我找你十万里——《星空》湮夫跨界艺术家插画师James R. Eads的画作，似乎一下子游离到了另一个世界。在他的笔下，一个个创思化身成一个个闪光的光点，五彩缤纷，随意萦绕，勾勒出一个个美轮美奂的画境，似有阳光的热烈，也有月光的浪漫，更有浩瀚星光似的唯美与空明，让人很容易就沉浸在这美妙的小宇宙中。 受梵高的绘画风格影响，他巧妙地将色彩与富有动感的笔触结合起来，使画面梦幻而富有冲击力。神秘缤纷的色彩、浩瀚如宇宙的笔触，自然与人就这样被James R. Eads用独特的绘画方法结合在一起，启发著人们去思考人与人、人与自然之间的关系。 欣赏作品： 我们尝试利用PIL库将gif图进行解析， 然后再重新合成gif图， 并改变帧的变化速率。 解析gif图代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#-*- coding: UTF-8 -*- import osfrom PIL import Image def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print ("saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile)) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def main(): processImage('1.gif') if __name__ == "__main__": main() 合成gif图代码：12345678910111213141516171819202122#-*- coding: UTF-8 -*- import imageio def create_gif(image_list, gif_name): frames = [] for image_name in image_list: frames.append(imageio.imread(image_name)) # Save them as frames into a gif imageio.mimsave(gif_name, frames, 'GIF', duration = 0.1) return def main(): image_list = ['1-0.png', '1-2.png', '1-4.png', '1-6.png', '1-8.png', '1-10.png'] gif_name = 'created_gif1.gif' create_gif(image_list, gif_name) if __name__ == "__main__": main() 某gif图解析后部分图片如下： gif图合成后：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PIL库里的基本知识概念]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create%2F</url>
    <content type="text"><![CDATA[首先，介绍一下PIL中的基本概念。PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。 1、 通道每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 方法getbands()的使用如下：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.getbands()('R', 'G', 'B')&gt;&gt;&gt;im_bands = im.getbands()&gt;&gt;&gt;len(im_bands)3&gt;&gt;&gt;print im_bands[0]R&gt;&gt;&gt;print im_bands[1]G&gt;&gt;&gt;print im_bands[2]B 2、 模式图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： 1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用如下：12345678&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;md = im.mode&gt;&gt;&gt;print mdRGB 3、 尺寸通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性mode的使用如下：1234567891011&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_size = im.size&gt;&gt;&gt;print im_size[0]800&gt;&gt;&gt;print im_size[1]450 4、 坐标系统PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 5、 调色板调色板模式 (“P”)使用一个颜色调色板为每个像素定义具体的颜色值 6、 信息使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 属性info的使用如下：1234567891011121314&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im_info = im.info&gt;&gt;&gt;im_info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;print im_info['jfif_version'](1, 1)&gt;&gt;&gt;print im_info['jfif']257 7、 滤波器对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为：resize(size, filter=None)=&gt; image12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_resize = im.resize((256,256))&gt;&gt;&gt;im_resize.size(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011&gt;&gt;&gt;im_resize0 = im.resize((256,256), Image.BILINEAR)&gt;&gt;&gt;im_resize0.size(256, 256)&gt;&gt;&gt;im_resize1 = im.resize((256,256), Image.BICUBIC)&gt;&gt;&gt;im_resize1.size(256, 256)&gt;&gt;&gt;im_resize2 = im.resize((256,256), Image.ANTIALIAS)&gt;&gt;&gt;im_resize2.size(256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None)12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200))&gt;&gt;&gt;im.size(200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011121314151617181920212223&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200),Image.BILINEAR)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.BICUBIC)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.ANTIALIAS)&gt;&gt;&gt;im.size(200, 112) 接着，说说PIL中的Image模块Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。 一、Image类的属性1、 Format定义：im.format ⇒ string or None 含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。 例子：12345678910&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.format'JPEG'注：test.jpg是JPEG图像，所以其文件格式为JPEG。&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.format'GIF'注：test.gif为GIF文件，所以其文件格式为GIF。 2、 Mode定义：im.mode ⇒ string 含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P' 3、 Size定义：im.size ⇒ (width, height) 含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt; im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt; im.size(400, 220) 4、 Palette定义：im.palette ⇒ palette or None 含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 例子：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im.palette&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P'&gt;&gt;&gt;im.palette&lt;PIL.ImagePalette.ImagePaletteobject at 0x035E7AD0&gt;&gt;&gt;&gt;pl= im.palettePl为ImagePalette类的实例。 5、 Info定义：im.info ⇒ dictionary 含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.info&#123;'duration':100, 'version': 'GIF89a', 'extension': ('NETSCAPE2.0', 795L), 'background': 0,'loop': 0&#125; 二、Image类的函数1、 New定义：Image.new(mode,size) ⇒ image Image.new(mode, size, color) ⇒ image 含义：使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 例子：123456789101112&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "#FF0000")&gt;&gt;&gt;im.show()图像im为128x128大小的红色图像。&gt;&gt;&gt;im= Image.new("RGB", (128, 128))&gt;&gt;&gt;im.show()图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "red")&gt;&gt;&gt;im.show图像im为128x128大小的红色图像。 2、 Open定义：Image.open(file) ⇒ image Image.open(file, mode) ⇒ image 含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。 用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 例子：123456&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg", "r")&gt;&gt;&gt;im.show() 3、 Blend定义：Image.blend(image1,image2, alpha) ⇒ image 含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;im =Image.blend(im01, im02, 0.3)&gt;&gt;&gt;im.show() Test01.jpg和test02.jpg两张图像size都为1024x768，mode为“RGB”。它们按照第一张70%的透明度，第二张30%的透明度，合成为一张。 4、 Composite定义：Image.composite(image1,image2, mask) ⇒ image 含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;g.mode'L'&gt;&gt;&gt; g.size(1024, 768)&gt;&gt;&gt;im= Image.composite(im01, im02, g)&gt;&gt;&gt;im.show() 5、 Eval定义：Image.eval(image,function) ⇒ image 含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;def fun(x): return x * 0.5&gt;&gt;&gt;im_eval = Image.eval(im01, fun)&gt;&gt;&gt;im_eval.show()&gt;&gt;&gt;im01.show() 图像im01如下图： 图像im_eval如下图： 图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。 6、 Frombuffer定义：Image.frombuffer(mode,size, data) ⇒ image Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image 含义：（New in PIL 1.1.4）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。 注意：版本1.1.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示：123im=Image.frombuffer(mode, size, data, "raw", mode, 0, 1)函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。 7、 Fromstring定义：Image.fromstring(mode,size, data) ⇒ image Image.fromstring(mode, size,data, decoder, parameters) ⇒ image 含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。 函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder. 注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。 8、 Merge定义：Image.merge(mode,bands) ⇒ image 含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) 例子：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 = Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r1,g1,b1 = im01.split()&gt;&gt;&gt;r2,g2,b2 = im02.split()&gt;&gt;&gt;r1.mode'L'&gt;&gt;&gt;r1.size(1024, 768)&gt;&gt;&gt;g1.mode'L'&gt;&gt;&gt;g1.size(1024, 768)&gt;&gt;&gt;r2.mode'L'&gt;&gt;&gt;g2.size(1024, 768)&gt;&gt;&gt;imgs=[r1,g2,b2]&gt;&gt;&gt;len(ImageMode.getmode("RGB").bands)3&gt;&gt;&gt;len(imgs)3&gt;&gt;&gt;im_merge = Image.merge("RGB", imgs)&gt;&gt;&gt;im_merge.show() 三、Image类的方法除非另作说明，Image类的所有方法都将返回一个Image类的新实例，这个实例对应于结果图像。 1、 Convert定义1：im.convert(mode)⇒ image 含义1：将当前图像转换为其他模式，并且返回新的图像。 当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。 当从一个颜色图像转换为黑白图像时，PIL库使用ITU-R601-2 luma转换公式： L = R 299/1000 + G 587/1000 + B * 114/1000 当转换为2位图像（模式“1”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。为了去掉图像抖动现象，可以使用dither选项。 例子1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im_c = im01.convert("L")&gt;&gt;&gt;im_c.mode'L'将“RGB”模式的im01图像，转换为“L”模式的im_c图像。定义2：im.convert(“P”,**options) ⇒ image含义2：这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：Dither=. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。Palette=. 控制调色板的产生。默认是WEB，这是标准的216色的“web palette”。要使用优化的调色板，则赋值为ADAPTIVE。Colors=. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色。例子2： 定义3：im.convert(mode,matrix) ⇒ image含义3：使用转换矩阵将一个“RGB”图像转换为“L”或者“RGB”图像。变量matrix为4或者16元组。例子3：下面的例子将一个RGB图像（根据ITU-R709线性校准，使用D65亮度）转换到CIE XYZ颜色空间：&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;rgb2xyz = ( 0.412453,0.357580, 0.180423, 0, 0.212671,0.715160, 0.072169, 0, 0.019334,0.119193, 0.950227, 0 ) &gt;&gt;&gt;im_c3 = im01.convert("L", rgb2xyz)&gt;&gt;&gt;im_c3.show()&gt;&gt;&gt;im_c3.mode'L' 2、 Copy定义：im.copy() ⇒ image 含义：拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。 例子：123&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_copy = im01.copy() 图像im_copy和im01完全一样。 3、 Crop定义：im.crop(box) ⇒ image 含义：从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。 这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box= [0, 0, 100, 100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im_crop.size(100, 100) 4、 Draft定义：im.draft(mode,size) 含义：配置图像文件加载器，使得返回一个与给定的模式和尺寸尽可能匹配的图像的版本。例如，用户可以使用这个方法，在加载一个彩色JPEG图像时将其转换为灰色图像，或者从一个PCD文件中提取一个128x192的版本。 注意：这个方法会适时地修改图像对象（精确地说，它会重新配置文件的读取器）。如果图像已经被加载，那这个方法就没有作用了。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.draft("L", (100,100))&lt;PIL.JpegImagePlugin.JpegImageFileimage mode=L size=128x96 at 0x3B69230&gt;&gt;&gt;&gt;im01.size(128, 96)&gt;&gt;&gt;im01.mode'L' 5、 Filter定义：im.filter(filter) ⇒ image 含义：返回一个使用给定滤波器处理过的图像的拷贝。可用滤波器需要参考ImageFilter模块。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_filter = im01.filter(ImageFilter.BLUR)&gt;&gt;&gt;im_filter.show() 图像im_filter比im01变得有些模糊了。 6、 Fromstring定义：im.fromstring(data) im.fromstring(data, decoder,parameters) 含义：与函数fromstring()一样，但是这个方法会将data加载到当前的图像中。 7、 Getbands定义：im.getbands()⇒ tuple of strings 含义：返回包括每个通道名称的元组。例如，对于RGB图像将返回（“R”，“G”，“B”）。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbands()('R', 'G', 'B') 8、 Getbbox定义：im.getbbox() ⇒ 4-tuple or None 含义：计算图像非零区域的包围盒。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbbox()(0, 0, 1024,768) 9、 Getcolors定义：im.getcolors() ⇒ a list of(count, color) tuples or None im.getcolors(maxcolors) ⇒ a list of (count, color) tuples or None 含义：（New in 1.1.5）返回一个（count，color）元组的无序list，其中count是对应颜色在图像中出现的次数。 如果变量maxcolors的值被超过，该方法将停止计算并返回空。变量maxcolors默认值为256。为了保证用户可以获取图像中的所有颜色，you can pass in size[0]*size[1]（请确保有足够的内存做这件事）。 例子：12345678910111213141516171819202122232425&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getcolors()&gt;&gt;&gt;im01.getcolors(256)&gt;&gt;&gt;ls= im01.getcolors(255)&gt;&gt;&gt;len(ls) Traceback (mostrecent call last): File "&lt;pyshell#201&gt;", line 1,in &lt;module&gt; len(ls)TypeError:object of type 'NoneType' has no len() 不知道为什么图像im01.getcolors()返回为空，这个后续需要进一步研究。 10、 Getdata定义：im.getdata() ⇒ sequence 含义：以包含像素值的sequence对象形式返回图像的内容。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。 注意：这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用list(im.getdata())，将它转换为普通的sequence。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;seq= im01.getdata()&gt;&gt;&gt;seq0 = list(seq)&gt;&gt;&gt;seq[0](11, 113, 198)&gt;&gt;&gt;seq[2](9, 111, 196)&gt;&gt;&gt;seq0[0](11, 113, 198)&gt;&gt;&gt;seq0[2](9, 111, 196)Sequence对象的每一个元素对应一个像素点的R、G和B三个值。 11、Getextrema定义：im.getextrema() ⇒ 2-tuple 含义：返回一个2元组，包括该图像中的最小和最大值。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getextrema()((0, 255), (0,255), (0, 255))该方法返回了R/G/B三个通道的最小和最大值的2元组。 12、Getpixel定义：im.getpixel(xy) ⇒ value or tuple 含义：返回给定位置的像素值。如果图像为多通道，则返回一个元组。 注意：该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.getpixel((1,1))(10, 112, 197)&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.getpixel((0,0))11 13、Histogram定义1：im.histogram()⇒ list 含义1：返回一个图像的直方图。这个直方图是关于像素数量的list，图像中的每个像素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值）。 二值图像（模式为“1”）当作灰度图像（模式为“L”）处理。 例子1：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;ls= im01.histogram()&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]359&gt;&gt;&gt;ls[256]295&gt;&gt;&gt;ls[767]109953图像im01为RGB图像，所以有768项。 定义2：im.histogram(mask)⇒ list 含义2：返回图像中模板图像非零地方的直方图。模板图像与处理图像的尺寸必须相同，并且要么是二值图像（模式为“1”），要么为灰度图像（模式为“L”）。 例子2：123456789101112131415161718&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;ls= im01.histogram(r)&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]0&gt;&gt;&gt;ls[256]248&gt;&gt;&gt;ls[767]109953 14、Load定义：im.load() 含义：为图像分配内存并从文件中加载它（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。 （New in 1.1.6）在1.1.6及以后的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如： pix = im.load() print pix[x, y] pix[x, y] =value 通过这个对象访问比方法getpixel()和putpixel()快很多。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;pix= im01.load()&gt;&gt;&gt;pix[0,0](11, 113, 198) 15、Offset定义：im.offset(xoffset,yoffset) ⇒ image 含义：（不赞成）返回按照给定位置的偏移对应的图像的拷贝。数据延续到图像的边缘。如果变量yoffset没有赋值，将假设其与变量xoffset一样。 不赞成使用这个方法，在PIL 1.2版本中去掉该方法。新的代码将使用ImageChops模块中的offset()函数。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;img= im01.offset(1,1) Traceback (mostrecent call last): File "&lt;pyshell#38&gt;", line 1,in &lt;module&gt; img = im01.offset(1,1) File"C:\Python27\lib\site-packages\PIL\Image.py", line 1246, in offset "Please call ImageChops.offset()instead.")Exception:offset() has been removed. Please call ImageChops.offset() instead.由此可见，该版本中已经去掉了方法offset()。 16、 Paste定义1：im.paste(image,box) 含义1：将一张图粘贴到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。 如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。 例子1：1234567891011121314151617181920212223&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box=[0,0,100,100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.size(100, 100)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im01.paste(im_crop, (200,200))&gt;&gt;&gt;im01.paste(im_crop, (500,500,600,600))&gt;&gt;&gt;im01.show()我们先从图像im01中裁剪出一个100x100的图像，它的模式与im01一样都是“RGB”。然后通过2元组和4元组的方式，将裁剪出来的图像粘贴到图像im01上。在图像im01的（200，200）和（500，500）两个位置分别出现了裁剪出来的100x100的图像。其结果如下图所示： 定义2：im.paste(colour,box) 含义2：它与定义1一样，但是它使用同一种颜色填充变量box对应的区域。对于单通道图像，变量colour为单个颜色值；对于多通道，则为一个元组。 例子2：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;im01.paste((0,256,0),(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的绿色方块。 &gt;&gt;&gt;im01.paste(255,(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的红色方块。对于多通道的图像，如果变量colour只给定一个数值，将只会应用于图像的第一个通道。如果是“RGB”模式的图像，将应用于红色通道。 定义3：im.paste(image,box, mask) 含义3：与定义1一样，但是它使用变量mask对应的模板图像来填充所对应的区域。可以使用模式为“1”、“L”或者“RGBA”的图像作为模板图像。模板图像的尺寸必须与变量image对应的图像尺寸一致。如果变量mask对应图像的值为255，则模板图像的值直接被拷贝过来；如果变量mask对应图像的值为0，则保持当前图像的原始值。变量mask对应图像的其他值，将对两张图像的值进行透明融合。 注意：如果变量image对应的为“RGBA”图像，即粘贴的图像模式为“RGBA”，则alpha通道被忽略。用户可以使用同样的图像作为原图像和模板图像。 例子3：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box =[500,500,600,600]&gt;&gt;&gt;im_crop =im01.crop(box)&gt;&gt;&gt;r,g,b =im_crop.split()&gt;&gt;&gt;im01.paste(im_crop, (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个半透明的100x100的方块。 定义4：im.paste(colour,box, mask) 含义4：与定义3一样，只是使用变量colour对应的单色来填充区域。 例子4：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;box= [500,500,600,600]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;r,g,b = im_crop.split()&gt;&gt;&gt;im01.paste((0,256,0), (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个100x100的绿色方块。 17、 Point定义1：im.point(table)⇒ image im.point(function) ⇒ image 含义1：返回给定查找表对应的图像像素值的拷贝。变量table为图像的每个通道设置256个值。如果使用变量function，其对应函数应该有一个参数。这个函数将对每个像素值使用一次，结果表格将应用于图像的所有通道。 如果图像的模式为“I（整数）”或者“F（浮点）”，用户必须使用function方式，function必须按照下面的格式： argument * scale+ offset 例如： out = im.point(lambda i: i * 1.2 + 10) 用户可以省略变量scale和offset。 例子1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_point_fun = im01.point(lambda i:i*1.2+10)&gt;&gt;&gt;im_point_fun.show()图像im_point_fun比原图im01亮度增加了很多；因为lambda表达式中对原图的每个像素点的值都做了增加操作。Lambda表达式是python中可以替代简单函数的一种方式，它只能封装有限的逻辑，但是对于某些情况，使用起来还是很方便的。定义lambda函数的形式如下：labmda参数：表达式lambda函数默认返回表达式的值。你也可以将其赋值给一个变量。lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。Lambda表达式的例子：&gt;&gt;&gt;range(10)[0, 1, 2, 3, 4,5, 6, 7, 8, 9]如果我们要对这10个数字，逐个做加一操作，可以使用如下表达式：&gt;&gt;&gt;map(lambda x:x+1, [y for y in range(10)])[1, 2, 3, 4, 5,6, 7, 8, 9, 10]函数map()是python的内置函数，其格式如下：map( func,seq1[, seq2...]Python函数式编程中的map()函数是将func作用于seq中的每一个元素，并用一个列表给出返回值。如果func为None，作用同zip()。当seq只有一个时，将func函数作用于这个seq的每个元素上，得到一个新的seq。例如：&gt;&gt;&gt;map(lambda x:x+10, range(10))[10, 11, 12, 13,14, 15, 16, 17, 18, 19]当seq多于一个时，map可以并行地对每个seq执行。每个seq的同一位置的元素在执行过一个多元的func函数之后，得到一个返回值，这些返回值放在一个结果列表中。需要注意的是，不同长度的多个seq是无法执行map函数的，会出现类型错误。例如：&gt;&gt;&gt;map(lambda x,y:x+y, [1,2,3],[4,5,6])[5, 7, 9]func是None的情况，它的目的是将多个列表相同位置的元素归并到一个元组，在现在已经有了专用的函数zip()了。例如：&gt;&gt;&gt;map(None, [1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip([1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。例如：&gt;&gt;&gt; a =[1,2,3]&gt;&gt;&gt; b =[2,3,4]&gt;&gt;&gt; b =[4,5,6]&gt;&gt;&gt; c =[4,5,6,7,8]&gt;&gt;&gt;zipped = zip(a,b)&gt;&gt;&gt;zipped[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(a,c)[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(*zipped)[(1, 2, 3), (4,5, 6)]定义2：im.point(table,mode) ⇒ imageim.point(function, mode) ⇒ image 含义2：与定义1一样，但是它会为输出图像指定一个新的模式。这个方法可以一步将模式为“L”和“P”的图像转换为模式为“1”的图像。 （New in 1.1.5）这个方法也可以将“L”图像转换为“I”和“F”模式，或者将16 位的“I”模式图像转换为“L”模式，此时必须使用65536项的查找表。 例子2：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt; im= r.point(lambda x:x*1.3+5, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))19图像im为全白图；&gt;&gt;&gt; im= r.point(lambda x:1, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))1图像im为全白图；&gt;&gt;&gt;im= r.point(lambda x:x*0, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))0图像im为全黑图； 18、 Putalpha定义：im.putalpha(band) 含义：将给定的通道拷贝到图像的alpha层。此处的图像模式必须为“RGBA”，变量band必须为“L”或者“1”。 （New in PIL 1.1.5）方法putalpha()也可以用于其他模式；图像原地转换为有alpha通道的模式（通常转换为“LA”或者“RGBA”）。变量band要么为图像，要么为颜色值（一个整数）。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.putalpha(100)&gt;&gt;&gt;im01.mode'RGBA'&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198,100) 19、 Putdata定义：im.putdata(data) im.putdata(data, scale, offset) 含义：从sequence对象中拷贝数据到当前图像，从图像的左上角（0，0）位置开始。变量scale和offset用来调整sequence中的值： pixel = value *scale + offset 如果变量scale忽略，则默认为1.0。如果变量offset忽略，则默认为0.0。 例子：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; r,g,b =im01.split()&gt;&gt;&gt;r.getpixel((0,0))11&gt;&gt;&gt;r.getpixel((1,0))10&gt;&gt;&gt;r.getpixel((2,0))9&gt;&gt;&gt;r.getpixel((3,0))6&gt;&gt;&gt;r.putdata([1,2,3,4])&gt;&gt;&gt;r.getpixel((0,0))1&gt;&gt;&gt;r.getpixel((1,0))2&gt;&gt;&gt;r.getpixel((2,0))3&gt;&gt;&gt;r.getpixel((3,0))4 20、 Putpalette定义：im.putpalette(sequence) 含义：为“P”或者“L”图像增加一个调色板。对于“L”图像，它的模式将变化为“P”。调色板序列需要包含768项整数，每组三个值表示对应像素的红，绿和蓝。用户可以使用768个byte的字符串代替这个整数序列。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.putpalette([1,2,3])&gt;&gt;&gt; r.mode'P' 21、 Putpixel定义：im.putpixel(xy,colour) 含义：修改指定位置上的像素值。对于单通道图像，变量colour为一个数值；对于多通道图像，变量colour为一个元组。 注意：这个方法执行比较慢。如果是1.1.6版本，像素访问对象（参考load方法）提供了一个更快的方法修改图像。如果用户要生成整幅图像，可以使用更有效的方法产生一个python list，然后使用方法putdata()将它拷贝到图像上去。对于更大的改变，使用方法paste或者ImageDraw模块。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.putpixel((0,0),(1,2,3))&gt;&gt;&gt;im01.getpixel((0,0))(1, 2, 3) 22、 Quantize定义：im.quantize(colors,**options) ⇒ image 含义：（不赞成）使用给定的颜色将“L”或者“RGB”图像转换为“P”图像，返回新的图像。 新的代码中，使用有自适应的调色板的convert方法来代替： out =im.convert(“P”, palette=Image.ADAPTIVE,colors=256) 23、 Resize定义：im.resize(size) ⇒ image im.resize(size, filter) ⇒ image 含义：返回改变尺寸的图像的拷贝。变量size是所要求的尺寸，是一个二元组：（width, height）。 变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 注意：在当前的版本中bilinear和bicubic滤波器不能很好地适应大比例的下采样（例如生成缩略图）。用户需要使用ANTIALIAS，除非速度比质量更重要。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; im= im01.resize((512, 384))&gt;&gt;&gt;im.size(512, 384) 24、 Rotate定义：im.rotate(angle) ⇒ image im.rotate(angle,filter=NEAREST, expand=0) ⇒ image 含义：返回一个按照给定角度顺时钟围绕图像中心旋转后的图像拷贝。 变量filter应该是NEAREST、BILINEAR或者BICUBIC之一。如果省略该变量，或者图像模式为“1”或者“P”，则默认为NEAREST。 变量expand，如果为true，表示输出图像足够大，可以装载旋转后的图像。如果为false或者缺省，则输出图像与输入图像尺寸一样大。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.size(1024, 768)&gt;&gt;&gt;im_30_1 = im01.rotate(30, Image.BICUBIC,1)&gt;&gt;&gt;im_30_1.size(1271, 1178) 25、Save定义：im.save(outfile,options…) im.save(outfile, format, options…) 含义：使用给定的文件名保存图像。如果变量format缺省，如果可能的话，则从文件名称的扩展名判断文件的格式。该方法返回为空。 关键字options为文件编写器提供一些额外的指令。如果编写器不能识别某个选项，它将忽略它。 用户可以使用文件对象代替文件名称。在这种情况下，用户必须指定文件格式。文件对象必须实现了seek()、tell()和write()方法，且其以二进制模式打开。 如果方法save()因为某些原因失败，这个方法将产生一个异常（通常为IOError异常）。如果发生了异常，该方法也有可能已经创建了文件，并向文件写入了一些数据。如果需要的话，用户的应用程序可以删除这个不完整的文件。 例子：1234567891011&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.save("D:\\Code\\Python\\test\\img\\test_rotate_30.jpg") 26、 Seek定义：im.seek(frame) 含义：在给定的文件序列中查找指定的帧。如果查找超越了序列的末尾，则产生一个EOFError异常。当文件序列被打开时，PIL库自动指定到第0帧上。 注意：在当前的版本上，大多数序列格式只允许用户查找下一帧，不能跳跃式查找指定的帧。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.mode'P'&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(2)&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.show()通过上面的code，分别找到了第2帧和第8帧图像。 27、 Show定义：im.show() 含义：显示一张图像。这个方法主要用于调试。 在Unix平台，这个方法将图像保存为临时的PPM文件，并且调用xv功能。 在widows中，它将图像保存为临时的BMP文件，并且使用标准的BMP显示功能显示它。 这个方法返回空。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.show() 28、 Split定义：im.split() ⇒ sequence 含义：返回当前图像各个通道组成的一个元组。例如，分离一个“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝）。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.size(1024, 768) 29、 Tell定义：im.tell() ⇒ integer 含义：返回当前帧所处位置，从0开始计算。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.tell()0&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.tell()8 30、 Thumbnail定义：im.thumbnail(size) im.thumbnail(size, filter) 含义：修改当前图像，使其包含一个自身的缩略图，该缩略图尺寸不大于给定的尺寸。这个方法会计算一个合适的缩略图尺寸，使其符合当前图像的宽高比，调用方法draft()配置文件读取器，最后改变图像的尺寸。 变量filter应该是NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果省略该变量，则默认为NEAREST。 注意：在当前PIL的版本中，滤波器bilinear和bicubic不能很好地适应缩略图产生。用户应该使用ANTIALIAS，图像质量最好。如果处理速度比图像质量更重要，可以选用其他滤波器。 这个方法在原图上进行修改。如果用户不想修改原图，可以使用方法copy()拷贝一个图像。这个方法返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.thumbnail((100,100))应该已经为图像im01创建了不大于100x100的缩略图。 31、 Tobitmap定义：im.tobitmap()⇒ string 含义：返回转换为X11的bitmap图像。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tobitmap() Traceback (mostrecent call last): File "&lt;pyshell#279&gt;", line 1,in &lt;module&gt; str0 = im01.tobitmap() File"C:\Python27\lib\site-packages\PIL\Image.py", line 710, in tobitmap raise ValueError("not a bitmap")ValueError: nota bitmap暂时不知道因为什么原因，需要debug。 32、 Tostring定义：im.tostring() ⇒ string 含义：返回一个使用标准“raw”编码器生成的包含像素数据的字符串。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tostring()Traceback (mostrecent call last): File "&lt;pyshell#281&gt;", line 1,in &lt;module&gt; str0= im01.tostring() File"C:\Python27\lib\site-packages\PIL\Image.py", line 695, in tostring "Please call tobytes() instead.")Exception:tostring() has been removed. Please call tobytes() instead.当前PIL版本已经去除了该方法。 33、 Transform定义1：im.transform(size,method, data) ⇒ image im.transform(size, method, data, filter) ⇒ image 含义1：使用给定的尺寸生成一张新的图像，与原图有相同的模式，使用给定的转换方式将原图数据拷贝到新的图像中。 在当前的PIL版本中，参数method为EXTENT（裁剪出一个矩形区域），AFFINE（仿射变换），QUAD（将正方形转换为矩形），MESH（一个操作映射多个正方形）或者PERSPECTIVE。 变量filter定义了对原始图像中像素的滤波器。在当前的版本中，变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 例子1：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans1 =im01.transform((300,300), Image.EXTENT, (0, 0, 600, 600))&gt;&gt;&gt; trans1.size(300, 300) 定义2：im.transform(size,EXTENT, data) ⇒ image im.transform(size, EXTENT, data, filter) ⇒ image 含义2：从图像中裁剪一个区域。 变量data为指定输入图像中两个坐标点的4元组(x0,y0,x1,y1)。输出图像为这两个坐标点之间像素的采样结果。例如，如果输入图像的(x0,y0)为输出图像的（0，0）点，(x1,y1)则与变量size一样。 这个方法可以用于在当前图像中裁剪，放大，缩小或者镜像一个任意的长方形。它比方法crop()稍慢，但是与resize操作一样快。 定义3：im.transform(size, AFFINE, data) ⇒ image im.transform(size, AFFINE,data, filter) ⇒ image 含义3：对当前的图像进行仿射变换，变换结果体现在给定尺寸的新图像中。 变量data是一个6元组(a,b,c,d,e,f)，包含一个仿射变换矩阵的第一个两行。输出图像中的每一个像素（x，y），新值由输入图像的位置（ax+by+c, dx+ey+f）的像素产生，使用最接近的像素进行近似。 这个方法用于原始图像的缩放、转换、旋转和裁剪。 例子3：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans3 =im01.transform((300,300), Image.AFFINE, (1,2,3,2,1,4))&gt;&gt;&gt; trans3.size(300, 300) 定义4：im.transform(size,QUAD, data) ⇒ image im.transform(size, QUAD, data, filter) ⇒ image 含义4：输入图像的一个四边形（通过四个角定义的区域）映射到给定尺寸的长方形。 变量data是一个8元组(x0,y0,x1,y1,x2,y2,x3,y3)，它包括源四边形的左上，左下，右下和右上四个角。 例子4：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans4 =im01.transform((300,300), Image.QUAD, (0,0,0,500,600,500,600,0))&gt;&gt;&gt; trans4.size(300, 300) 定义5：im.transform(size,MESH, data) ⇒ image im.transform(size, MESH, data, filter) ⇒ image 含义5：与QUAD类似，但是变量data是目标长方形和对应源四边形的list。 定义6：im.transform(size,PERSPECTIVE, data) ⇒ image im.transform(size, PERSPECTIVE, data, filter) ⇒ image 含义6：对当前图像进行透视变换，产生给定尺寸的新图像。 变量data是一个8元组(a,b,c,d,e,f,g,h)，包括一个透视变换的系数。对于输出图像中的每个像素点，新的值来自于输入图像的位置的(a x + b y + c)/(g x + h y + 1), (d x+ e y + f)/(g x + h y + 1)像素，使用最接近的像素进行近似。 这个方法用于原始图像的2D透视。 例子6：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; trans6= im01.transform((300,300), Image.PERSPECTIVE, (1,2,3,2,1,6,1,2))&gt;&gt;&gt;trans6.size(300, 300) 34、 Transpose定义：im.transpose(method)⇒ image 含义：返回当前图像的翻转或者旋转的拷贝。 变量method的取值为：FLIP_LEFT_RIGHT，FLIP_TOP_BOTTOM，ROTATE_90，ROTATE_180，或者ROTATE_270。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im= im01.transpose(Image.FLIP_LEFT_RIGHT)图像im为图像im01的水平方向镜像。 35、Verify定义：im.verify() 含义：尝试判断文件是否损坏，实际上并没有对图像数据进行解析。如果这个方法发现了任何问题，它将产生对应的异常。这个方法只工作于刚打开的图像；如果图像已经被加载，该方法的结果将会是未定义的。如果用户在使用这个方法后需要加载图像，用户需要重新打开图像文件。 注意：这个方法不能捕获所有的错误；要捕获解码错误，用户必须加载整个图像。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.verify()没有任何输出，表示图像im01是没有损坏的。]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫小实例</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>pymatplotlib库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
