<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-84-Largest Rectangle in Histogram]]></title>
    <url>%2F2019%2F05%2F05%2Fleetcode-84%2F</url>
    <content type="text"></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-85-Maximal Rectangle]]></title>
    <url>%2F2019%2F05%2F05%2Fleetcode-85%2F</url>
    <content type="text"></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part6]]></title>
    <url>%2F2019%2F05%2F05%2FStudyPachong6%2F</url>
    <content type="text"></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part5]]></title>
    <url>%2F2019%2F05%2F05%2FStudyPachong5%2F</url>
    <content type="text"><![CDATA[动态爬取解决方案 之 手动分析动态的标志进入一个网页，鼠标到处点，滑轮上下滚，各种框框各种信息都蹦出来了，但是网页链接没变过，网页也没重新刷新过 比如：逛网页版的网易云音乐的评论时，无论评论翻到第几页，网址也不会改变；逛知乎时，鼠标不停往下滚，只要下面还有回答，就会不断的加载出来，同样网址也不会改变 类似这样能不转跳不刷新就能加载新信息的网页，就是用了动态加载。 分析什么首先记住——所有信息在理论上都可以通过请求（链接）获得然后记住——有些请求需要提交参数，检查headers什么的来防爬附加一点——大多数动态加载的信息，通常都是json数据 有了这些指引提示我们就能描绘出大概的分析思路 首先我们要找到json数据请求链接，通过F12捉包获得，这种包属于xhr或js里 然后我们通过分析多个json数据的请求链接的参数，规律，推出所有链接的结构 如果json数据是一个post包，我们还要分析要post的参数的内容，规律（加密的另谈） 分析服务器是否检查请求的headers，如是，需要哪些额外headers（指user-agent外） 完成以上四步通常就能获得目标json数据，剩下的就是分析json数据本身，把目标提取出来 引导实例以某宝为例，随便搜一个商品进去。打开F12，换到Network捉js的包，点到评论那里，很快就弹出很多个包，逐个查看其response，很快就确定了目标包，然后评论换页，捉多几个供链接分析用。 这是一个包的请求链接 通过对比刚才捉到的多个包的链接，和多次试验性发送请求，我们可以分析出链接结构——ua（包括ua）之后参数是不影响请求结果的，currentPageNum是评论页数，auctionNumId是商品id，userNumId可以不要，这样就足以构造所有json数据的请求链接，至于一些决定排序的参数这里就不再多分析。 多次试验后发现这个请求链接不需要提交数据，headers加个user-agent就可以返回数据 但是taobao返回的json数据有坑，注意一下 然后提取json数据，这样动态问题就解决了，可以完整的写出爬虫。jd评价的爬取和淘宝类似。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport reheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36' &#125;def get_ids(keyword,psort): ids = [] pages = int(input("爬商品前几页,每页30个商品")) for i in range(1,pages+1): url = 'https://search.jd.com/Search?keyword=&#123;&#125;&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;psort=&#123;&#125;&amp;click=0&amp;page=&#123;&#125;&amp;s=&#123;&#125;'.format(keyword,psort,str(i*2-1),str(60*i-59)) r = requests.get(url,headers=headers) response = r.content.decode('utf-8') ids.extend(re.findall(r'li data-sku="(\d+)"',response)) print(len(ids),ids) if input('是否只爬前几件商品yes/no')=='yes': nums = int(input('只爬前n件商品,n&lt;=&#123;&#125;'.format(len(ids)))) else: nums = len(ids) return ids,numsdef get_comment(ids_and_nums): pages = int(input('爬评论的前几页,10个评论每页')) for num in range(ids_and_nums[1]): comments = [];types = [];scores = [] f.write('https://item.jd.com/&#123;&#125;.html '.format(ids_and_nums[0][num])+'\n\n') for i in range(pages): url = 'https://club.jd.com/productpage/p-&#123;&#125;-s-0-t-1-p-&#123;&#125;.html'.format(ids_and_nums[0][num],str(i)) r = requests.get(url,headers=headers) for each in r.json()['comments']: f.write('得分：&#123;&#125;\n'.format('*' *int(each['score']))) f.write('评论：'+each['content']+'\n') f.write('类型：'+each['productColor']+'\n\n') #列表储存，需要时使用 #comments.append(each['content']) #types.append(each['productColor']) #scores.append(each['score']) f.write('\n\n\n\n')keyword = input("请输入商品名")psort = input("请输入排序的数字代号，0：默认综合 3：按销量 4：按评论")ids_and_nums=get_ids(keyword,psort)with open(keyword+'.txt','w',encoding='utf-8') as f: get_comment(ids_and_nums)#通用json，但是只按时间排序#https://club.jd.com/productpage/p-1982079424-s-0-t-1-p-0.html#通用json但是只按推荐排序#https://sclub.jd.com/comment/productPageComments.action?productId=3281156&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part4]]></title>
    <url>%2F2019%2F05%2F05%2FStudyPachong4%2F</url>
    <content type="text"><![CDATA[初遇json&amp;爬取某宝商品信息JSON是什么 json是轻量级的文本数据交换格式，符合json的格式的字符串叫json字符串，其格式就像python中字符串化后的字典，有时字典中还杂着列表字典，但是里面的数据都被双引号包着，下面是一个例子1234567&apos;&#123;&quot;Africa&quot;: [&#123; &quot;name&quot;:&quot;蜜獾&quot; , &quot;nickname&quot;:&quot;平头哥&quot; &#125;, &#123; &quot;name&quot;:&quot;虫子&quot; , &quot;nickname&quot;:&quot;小辣条&quot; &#125;, &#123; &quot;name&quot;:&quot;毒蛇&quot; , &quot;nickname&quot;:&quot;大面筋&quot; &#125; ] &#125;&apos;#这是理想化的数据，实际上看到的json是不分行堆在一起，而且更多时候用unicode编码取代中文 而且为了能更好的传输各种语言，json对非英语的字符串进行了Unicode编码，于是我们直接看到的json数据通常都是带着\uxxxx的字符串而不会带着中文，json数据还会堆在一起不换行，给我们的分析带来了困难，不过我们有json 模块让它转回中文，更有一个 https://www.bejson.com/ 把它转回中文同时排版，分析json数据时多用这个工具。 在哪 有时F12源码中能看到完整的信息，request回来后就残缺到没有价值，这就说明网页使用了动态或者ajax技术，而这些技术所加载的信息，就有json的身影。为了顺利爬取目标，我们需要找到json数据。 json数据有时会直接出在对原链接request的结果中，作为信息等待被加载到网页中 有时会存在于独立的链接里，需要捉包获取链接再打开获得（而且这种链接的构造很重要） json 模块 JSON是JavaScript原生格式，所以在JavaScript中处理JSON数据不需要任何特殊的API或工具包。而像python，需要json模块，python自带。 json 模块提供了一种很简单的方式来编码和解码JSON数据，实现了JSON数据(字符串)和python对象(字典)的相互转换。 主要两个方法及常用参数： json.dumps(obj,ensure_ascii=True): 将一个字典（obj）转换为JSON编码的字符串，ensure_ascii默认为True，全部是ascii字符，中文会以unicode编码形式显示如\u597d；设置为False时保持中文 json.loads(s,encoding=): 将一个JSON编码的字符串（s）转换回字典,如果传入的json字符串的编码不是UTF-8的话，需要用encoding指定字符编码 如果你要处理的是文件而不是字符串/字典，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。12345678# 编码成json数据写入，data是字典with open('data.json', 'w') as f: json.dump(data, f)# 读取json数据并解码，data是字典with open('data.json', 'r') as f: data = json.load(f)另：requests对象的json()方法也可以把json数据转为字典，dict = r.json(encoding=) 以下实战代码已无法成功运行（淘宝要求先登陆后搜索，成功运行代码见另一篇博客）实战：简单爬取淘宝商品信息 爬虫领域内json的知识知道这些就行，那么马上来个实战了解一下怎样提取json中的数据，加深对json的认识吧，正好可以拿某宝来试手，商品的json数据直接出在对原链接request的结果中，不用捉包。（然而大多数json数据不会这样出现，这里选择某宝方便展示） 构造链接（重要）重要，但这也是要培养的能力，在这里只详细讲一次思路，以后靠自己分析 构造链接的原则是尽可能多的相关参数，尽可能少的无关参数，网址中?之后用&amp;连起来的赋值关系就是那些参数，这些参数会传到服务器中，服务器根据它们来返回数据。爬虫中，页数，排序，日期等这类的参数是关键。我们要动态的修改这些参数来构造链接，观察能力很重要。还有构造链接时要多requests下来测试哪些是相关参数，哪些参数是无关紧要的，不是只看浏览器就行的 先进入官网搜索一件商品，这里以GTX1060为例，第一次出现的链接如下，1&apos;https://s.taobao.com/search?initiative_id=tbindexz_20170306&amp;ie=utf8&amp;spm=a21bo.2017.201856-taobao-item.2&amp;sourceId=tb.index&amp;search_type=item&amp;ssid=s5-e&amp;commend=all&amp;imgfile=&amp;q=GTX1060&amp;suggest=history_1&amp;_input_charset=utf-8&amp;wq=GTX&amp;suggest_query=GTX&amp;source=suggest&apos; 很长是吧，能大约的看到日期，商品名之类的参数，但是大部分参数都看不懂，我们假设部分参数是不影响爬取结果的，于是我们来继续按下看看有什么变化，当再次按下搜索键 链接变短了,在按多几下都是这个链接了1&apos;https://s.taobao.com/search?q=GTX1060&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=staobaoz_20180428&amp;ie=utf8&apos;#初步结构 为了确保泛用性，我们换个商品再搜索，发现链接除q参数（商品名）改变外，其他一模一样，由此我们初步确定了链接结构，q参数是商品名，initiative_id是当天日期，其他不用变 但我们的还要有翻页和排序的功能没实现，链接里也看不到和它们有关的参数，因此我们要继续按来引相关参数出来，点击排序那排按钮 发现又多了一个sort参数，不同的排序方式对应不同的值，有default（默认综合排序），sale-desc（按销量），renqi-desc（按人气）等 按下一页，又多了bcoffset，p4ppushleft，s三个参数，经测试只有s参数有用，其他两个都不影响爬取结果（直接去掉），s是页数相关参数，值是44的倍数（因为每页加载44件商品），第一页0，第二页44，第三页88…… 到此就捕捉到q，initiative_id，sort，s等参数了，如果想增加其它相关参数，就自己到处按捣鼓吧，下面就这4个参数进行构造，可以format格式化，也可以将参数通过requests.get()的params参数传入，下面选择格式化 12#使用格式化输出，传四个字符串变量进去url = &apos;https://s.taobao.com/search?q=&#123;name&#125;&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=&#123;date&#125;&amp;ie=utf8&amp;s=&#123;num&#125;&amp;sort=&#123;sort&#125;&apos;.format(name=,date=,num=,sort=) 剩下的就是整合到循环进行多页爬取了，代码最后贴上，下面在看看json数据怎样提取。 json数据分析&amp;提取先拿一个链接requests下来保存到txt看看先，打开后看到一大堆又字典又列表的东西，仔细一看这货是符合json格式的字符串，里面有我们要的信息。 我们知道json数据本质是字符串，也可以用json.load()转化为字典，这样的话就有两种提取信息的方法 直接用正则对字符串匹配，缺点是当json存在\uxxxx的unicode编码时你会得到\uxxxx而不是中文，然而还是有办法绕过编码问题——可以通过str(json.load())得到字典（已解码回中文）后再强转为字符串再匹配，但是要注意单引号问题 转为字典后逐层索引下去，缺点是当结构过于复杂时，索引也比较麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from datetime import dateimport reimport jsonimport requestsdef taobao(keyword,pages,select_type,date_): headers = &#123; 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36'&#125; url = 'https://s.taobao.com/search?q=&#123;&#125;&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=&#123;&#125;&amp;ie=utf8&amp;sort=&#123;&#125;'.format(keyword, date_, selections[select_type]) titles=[];item_ids=[];prices=[];locations=[];sales=[];seller_ids=[];store_names=[] for i in range(pages): r = requests.get(url+'&amp;s=&#123;&#125;'.format(str(i*44)),headers=headers,) data = re.search(r'g_page_config = (.+);',r.text)#捕捉json字符串 data = json.loads(data.group(1),encoding='utf-8')#json转dict for auction in data['mods']['itemlist']['data']['auctions']: titles.append(auction['raw_title'])#商品名 item_ids.append(auction['nid'])#商品id prices.append(auction['view_price'])#价格 locations.append(auction['item_loc'])#货源 sales.append(auction['view_sales'])#卖出数量 seller_ids.append(auction['user_id']) #商家id store_names.append(auction['nick'])#店铺名 #正则实现 '''titles.extend(re.findall(r'"raw_title":"(.+?)"',r.text,re.I)) item_ids.extend( re.findall(r'"nid":"(.+?)"',r.text,re.I)) prices.extend(re.findall(r'"view_price":"([^"]+)"',r.text,re.I)) locations.extend(re.findall(r'"item_loc":"([^"]+)"',r.text,re.I)) sales.extend(re.findall(r'"view_sales":"([^"]+)"',r.text,re.I)) seller_ids.extend(re.findall(r'"user_id":"([^"]+)"',r.text,re.I)) store_names.extend(re.findall(r'"nick":"([^"]+)"',r.text,re.I)) ''' #单纯打印出来看 print (len(titles),len(item_ids),len(prices),len(locations),len(sales),len(seller_ids),len(store_names)) print(titles) print(item_ids) print(prices) print(locations) print(sales) print(seller_ids) print(store_names)selections = &#123;'0':'default', '1':'renqi-desc', '2':'sale-desc'&#125;keyword = input('输入商品名\n')pages = int(input('爬多少页\n'))date_ = 'staobaoz_' + str(date.today()).replace('-','')if input('yes/no for 改排序方式,默认综合')=='yes': select_type = input('输入1按人气，输入2按销量')else: select_type = '0'taobao(keyword,pages,select_type,date_) 补充： 12345url = 'https://s.taobao.com/search?q=GTX1060&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=staobaoz_20180428&amp;ie=utf8'headers = &#123;'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36'&#125;r =requests.get(url, headers=headers)with open('taobao.txt','w', encoding='utf-8') as f: f.write(r.text) 结果为： 要人登陆了再允许搜索商品]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part3]]></title>
    <url>%2F2019%2F05%2F05%2FStudyPachong3%2F</url>
    <content type="text"><![CDATA[强大的正则表达式，re模块特性 其实BeautifulSoup也是用正则实现的，而且它find_all的参数里还能接收正则 BeautifulSoup用的是节点定位，可能会出现多个符合条件的节点（却没有目标信息）；正则是直接针对目标信息，以字符为单位匹配，一次筛选出正确结果 有时候完整的信息不是你想要的，你只想取它的某一部分，正则能搞定，BeautifulSoup只能先获取完整信息再分离。 如果你要匹配一个ip地址，正则表达式会是这样匹配ip地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d).){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) re 模块python 自带模块，直接导入即可。有匹配，替换等方法。 匹配规则（pattern）规则其实是一个原字符串如r’表达式’/r”表达式”，较正式的叫法是模式字符串。匹配以单个字符为单位（除括号能把多个字符打包成分组（整体）来匹配） 表达式本质是字符串，不要单引（双引）号里套单引（双引）号，会出错。 字符匹配 任一字符(空格也算)——就是匹配这个字符，某些字符因为在正则中有特殊用途需前加反斜杠转义如 [ { . | ( ) ^ * + ? $ .——英文句号，匹配除换行符\n外的任意单个字符 []——匹配中括号里的任一字符，与-结合还能表示范围内的任一字符，中括号内的字符除\外会自动转义，还有小心多个中括号嵌套错误 [^]——中括号最前面加^,与[ ]反义,匹配一个不在中括号里的字符，也可以用横杠- 123456r'[abcd]'#匹配一个a或b或c或dr'[0-9]'#匹配一个0至9的数，-的作用域是左右各一个字符r'[a-z]' r'[A-Z]'#分别匹配a到z或A到Z的一个字母r'[12-89]'#注意因为是单字符匹配,匹配的是1，2到8的数，9（即1到9的一个数），不是12到89的数r'[&#123;.|()^*+?$\\]'#匹配 &#123; . | ( ) ^ * + ? $ \中任一个,\要转义r'[^a-zA-Z]'#匹配一个不是字母的字符 分组&amp; 或 &amp;转义 ()——括号，表达式分组（第n组，n=1，2，3….99，从左往右数），并形成子表达式 (?P&lt; name &gt;)——拥有括号的功能，但能为该分组再指定一个自定名字 (?P=name)——引用分配过名字的分组，但没有分组功能 |——或，左右规则任意匹配一个，从左往右尝试匹配，一旦成功就跳过后面的规则。|没被包在括号中间的话它的作用域是整个表达式，被包的话作用域在括号内 \——反斜杠，后接功能字有符转义功能，后接数字（1到99）有引用分组的功能，后接某些字母又有特殊功能 1234r'abc|def|ghi'#匹配abc或def或ghir'ma(?:k|d)e'#匹配make或mader'(abc)def\1'#相当于r'(abc)defabc',匹配abcdefabcr'(?P&lt;ok&gt;abc)f(?P=ok)'#为(abc)子组分配了“ok”的名字，然后再引用，匹配abcfabc 预定字符集 \d——匹配任一个数字（0~9） \D——匹配一个非数字字符，与\d互补 \s——匹配一个空白字符，包括空格，\t,\n,\r,\n,\f,\v \S——匹配一个非空白字符 \w——匹配一个单词字符。unicode下匹配各种语言的单个字符，单个数字，和下横线。ASCII下匹配单个英文字母，单个数字，和下横线 \W——匹配一个非单词字符1r'\w' #能匹配'物语&amp;ものがたり'中的：物，语，も，の，が，た，り，汉语日语的单字，其他语言同理 数量词（接在字符或子组后） {n}——作用于前一个字符或子表达式，匹配它重复n次 {min,max}——作用于前一个字符或子表达式，匹配它重复重复多少次min~max次，min和max可只写一个设置重复下限或上限，但逗号不能省，不写min时min默认为0 *——星号，作用于前一个字符或子表达式，匹配它零次或多次 +——作用于前一个字符或子表达式，匹配它至少一次 ?——作用于前一个字符或子表达式，匹配它零次或一次 1234r'z&#123;3&#125;'#匹配zzzr'z&#123;0,3&#125;'#匹配z或zz或zzzr'(?:abc)&#123;2&#125;'#对子表达式匹配两次，匹配abcabc，(?:)是一个用法，不分组的意思，详看后面#星号加号问号同理 非贪婪模式 在数量词后接?，对前面的数量词开启非贪婪模式，意思就是在能匹配的前提下尽可能少的重复匹配。 正则默认开启贪婪模式 12r'&lt;.+&gt;'#默认贪婪，对于'&lt;abc&gt;&lt;def&gt;'能匹配到'&lt;abc&gt;&lt;def&gt;'整条，因为.贪婪地把尖括号也匹配掉了r'&lt;.+?&gt;'#非贪婪，对于'&lt;abc&gt;&lt;def&gt;'能匹配到'&lt;abc&gt;'和'&lt;def&gt;' 边界匹配 ^——放在表达式的最前面，作用域是表达式，在多行模式中，在每一行匹配字符串开头（多行模式要手动开启，否则和\A没什么区别） $——放在表达式的最后面，作用域是表达式，在多行模式中，在每一行匹配字符串末尾（多行模式要手动开启，否则和\Z没什么区别） \A——放在表达式的最前面，作用域是表达式，匹配字符串开头，不能多行匹配 \Z——放在表达式的最后面，作用域是表达式，匹配字符串末尾，不能多行匹配 \b——不匹配字符，只匹配一个边界，匹配\w和\W或\W和\w的边界（单词字符和非单词字符的边界） \B——不匹配字符，只匹配一个边界，与\b相反，匹配\w和\w或\W和\W的边界 123456r'^abc|^def'#匹配abc开头或def开头，开启了多行模式时，对字符串'abcd\ndefh'能匹配出abc，def两个r'abc$|def$'#匹配abc结尾或def结尾，开启了多行模式时，对字符串'0abc\n0def'能匹配出abc，def两个r'\Aabc'#匹配abc开头，因为不能多行匹配，就算开启多行模式，对字符串'abcd\nabcd'只能匹配到前面的abc#\Z同理r'\w\b\W'#匹配“单词字符+非单词字符”的结构如'a!','1%'#\B同理 Python 的re模块内置函数几乎都有一个flags参数，以位运算的方式将多个标志位相加。其中有两个模式：单行（re.DOTALL, 或者re.S）和多行（re.MULTILINE, 或者re.M）模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152单行模式 re.DOTALL在单行模式里，文本被强制当作单行来匹配，什么样的文本不会被当作单行？就是里面包含有换行符的文本，比如：This is the first line.\nThis is the second line.\nThis is the third line.点号（.）能匹配所有字符，换行符例外。现在我们希望能匹配出整个字符串，当用点号（.）匹配上面这个字符串时，在换行符的地方，匹配停止。例如：&gt;&gt;&gt; a = 'This is the first line.\nThis is the second line.\nThis is the third line.'&gt;&gt;&gt; print aThis is the first line.This is the second line.This is the third line.&gt;&gt;&gt; import re&gt;&gt;&gt; p = re.match(r'This.*line.' ,a)&gt;&gt;&gt; p.group(0)'This is the first line.'&gt;&gt;&gt;在上面的例子里，即使是默认贪婪（greedy）的匹配，仍然在第一行的结尾初停止了匹配，而在单行模式下，换行符被当作普通字符，被点号（.）匹配：&gt;&gt;&gt; q = re.match(r'This.*line.', a, flags=re.DOTALL)&gt;&gt;&gt; q.group(0)'This is the first line.\nThis is the second line.\nThis is the third line.'点号（.）匹配了包括换行符在内的所有字符。所以，更本质的说法是单行模式改变了点号（.）的匹配行为多行模式 re.MULTILINE在多行模式里，文本被强制当作多行来匹配。正如上面单行模式里说的，默认情况下，一个包含换行符的字符串总是被当作多行处理。但是行首符^和行尾符$仅仅匹配整个字符串的起始和结尾。这个时候，包含换行符的字符串又好像被当作一个单行处理。在下面的例子里，我们希望能将三句话分别匹配出来。用re.findall( )显示所有的匹配项&gt;&gt;&gt; a = 'This is the first line.\nThis is the second line.\nThis is the third line.'&gt;&gt;&gt; print aThis is the first line.This is the second line.This is the third line.&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r'^This.*line.$', a)[]&gt;&gt;&gt;默认点号不匹配换行符，我们需要设置re.DOTALL。&gt;&gt;&gt; re.findall(r'^This.*line.$', a, flags=re.DOTALL)['This is the first line.\nThis is the second line.\nThis is the third line.']&gt;&gt;&gt;匹配出了整句话，因为默认是贪婪模式，用问号切换成非贪婪模式：&gt;&gt;&gt; re.findall(r'^This.*?line.$', a, flags=re.DOTALL)['This is the first line.\nThis is the second line.\nThis is the third line.']&gt;&gt;&gt;仍然是整句话，这是因为^和$只匹配整个字符串的起始和结束。在多行模式下，^除了匹配整个字符串的起始位置，还匹配换行符后面的位置；$除了匹配整个字符串的结束位置，还匹配换行符前面的位置.&gt;&gt;&gt; re.findall(r'^This.*?line.$', a, flags=re.DOTALL+re.MULTILINE)['This is the first line.', 'This is the second line.', 'This is the third line.']&gt;&gt;&gt;更本质的说法是多行模式改变了^和$的匹配行为 特殊构造（不作为分组,不被findall捕获） (?:)——取消括号的分组功能，使其不会被findall方法捕获 (?#)——#后写注释内容，整个(?#)会被忽略 A(?=)——A之后的字符串需要匹配括号里的表达式A才会被匹配,一定用在表达式的最后（A是表达式，(?=)内的表达式不会被匹配捕捉，下同） A(?!)——A之后的字符串需要不匹配括号里的表达式A才会被匹配，一定用在表达式的最后 (?&lt;=)A——A之前的字符串需要匹配括号里的表达式A才会被匹配，一定用在表达式的最前，括号内的表达式需固定长度不能使用除{n}外的数量词 (?&lt;!)A——A之前的字符串需要不匹配括号里的表达式A才会被匹配，一定用在表达式的最前，括号内的表达式需固定长度不能使用除{n}外的数量词 1234r'(ab(?=cde))'#匹配后面是cde的abr'a(?!\d+)'#匹配后面不跟一串数字的a，后括号可用所有数量词r'(?&lt;=abc)de'#匹配前面是abc的der'(?&lt;!\d&#123;3&#125;)a'#匹配前面不是三个数字的a，前括号可以用&#123;n&#125;但是不能用不定量的数量词 (?iLmsux)——放在表达式最前面，为所在的表达式设置模式，”i”, “L”, “m”, “s”, “u”, “x”，它们不匹配任何字串，对应python中re模块当中的(re.I, re.L, re.M, re.S, re.U, re.X)的6种模式,下面flag参数讲 1r'(?i)abc'#“i”对应re.I，忽略大小写模式，能匹配Abc，ABC，abc等 方法&amp;参数相比于繁杂的规则，方法则要简单多了，常用的就这几个： re.search(pattern,string,flags=0),返回第一个匹配的match对象（内含匹配字符串的信息） re.findall(pattern,string,flags=0),返回所有匹配分组的字符串组成的列表，没设置分组相当于整个表达式就是一个分组 如果表达式有多个分组，会返回复杂的列表，因此findall中的表达式通常只有一个分组 re.finditer(pattern,string,flags=0)，同findall功能，但是返回的是迭代器 12re.findall(r'\d+(abc)\d+','1abc1,2abc2')#分组为(abc),findall只捕捉被数字包起来的abc返回列表['abc','abc']re.findall(r'((?:ab)&#123;2&#125;\d)\d','abab11,abab22')#整个表达式匹配abab加一个两位数，(?:)取消了ab的分组,findall只捕捉abab加一个数，返回列表['abab1','abab2'] pattern = re.compile(pattern,flags=0),把规则打包返回（如多次使用该规则），相当与pattern和flag的合体，当成pattern使用可免去设置flags re.sub(pattern,repl,string,count=0,flags)把匹配到的部分用指定字符串repl替换，count设置最大的可以被替换的匹配到的字符串的个数，默认为零替换所有 参数： pattern：接收模式字符串，即表达式，也可以接收打包的规则 string：接收待匹配字符串，如html文档 flags：模式（标签），接受以下模式，多个模式用“|”分开如 flags=re.I|re.M1234567re.I = re.IGNORECASE 忽略大小写re.L = re.LOCALE 支持当前语言,为了支持多语言版本的字符集使用环境re.U = re.UNICODE 使用w,W,b,B这些元字符时将按照UNICODE定义的属性re.M = re.MULTILINE 开启多行模式re.S = re.DOTALL 使.能匹配换行符\nre.X = re.VERBOSE 可以忽略正则表达式中的空白和#号的注释,不匹配空格和#注释re.A 开启ASCII模式 match对象方法列出常用方法，下面的match是对象 match.group(id/name)id是分组序号（1~99）,name是分组的自定名字，返回指定分组的字符串；不传参数是返回整条匹配字符串 match.start(id/name),match.end(id/name),match.span(id/name),分别返回指定分组字符串在整个字符串中的开始位置，结束位置，范围。]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part2]]></title>
    <url>%2F2019%2F05%2F05%2FStudyPachong2%2F</url>
    <content type="text"><![CDATA[实战：requests+BeautifulSoup实现静态爬取静态网页是指一次性加载所有内容的网页，爬虫一次请求便能得到所有信息，对爬虫非常友好。 豆瓣top250电影信息爬取网站为：https://movie.douban.com/top250 1打开F12/右键检查第一个电影，分析源码先，发现每个&lt;li&gt;标签就对应着一个电影的信息。 1我们来爬取每部电影的图片，名称，导演演员，类型，评分，和它的一句话总结，继续对&lt;li&gt;标签进行分析,又发现信息又在&lt;div class="info"&gt;标签里，而这标签只存在于&lt;li&gt;标签中，其它地方不存在，这样可以用find_all()方法把他们全部分离出来。这里不选择&lt;li&gt;标签是它没有唯一性，电影以外的内容也有&lt;li&gt;标签。 12345678910111213布置好伪装后就可一开始根据每个&lt;div class="info"&gt;标签进行信息筛选了:图片链接是&lt;div class="info"&gt;的上上个兄弟标签&lt;div class="pic"&gt;的孙子&lt;img&gt;的src属性的值电影名有多个，都在&lt;div class="hd"&gt;标签里，用get_text()把它们串起来导演演员是&lt;p class&gt;标签的第一段字符串类型是&lt;p class&gt;标签的第二段字符串评分和评分人数都在&lt;div class="star"&gt;标签里，又用get_text()串起来一句话总结直属于&lt;span class="inq"&gt;标签html中的&amp;nbsp对应字符串中的\xa0,可用replace方法替换掉 1234567891011121314151617url = 'https://movie.douban.com/top250'headers = &#123;'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36'&#125;r=requests.get(url,headers=headers)soup = BeautifulSoup(r.text,'lxml')for each in soup.find_all('div',class_='info'): img_url = each.previous_sibling.previous_sibling.a.img['src']#图片链接 ''' with open('*.jpg','wb') as img:#还可以顺便下载回来，名字自起 img.write(requests.get(img_url,headers=headers).content) ''' title=each.find('div',class_='hd').get_text(strip=True).replace('\xa0','')#标题 actor = list(each.find('p',class_='').strings)[0].strip().replace('\xa0','')#导演演员 type_ = list(each.find('p',class_='').strings)[1].strip().replace('\xa0','')#类型 score = each.find('div',class_='star').get_text('/',strip=True)#评分及人数 quote = each.find('span',class_='inq').string#一句话总结 print([img_url,title,actor,type_,score,quote])#这里只简单打出来看下，怎样存储由你来决定 但是这样只有25部电影, ‘https://movie.douban.com/top250&#39; 指向第一页，我们现在只爬了一页，其实还有9页还没爬啊，这是就要构造网址了。 我们点到第二页，发现网址变成了 https://movie.douban.com/top2?start=25&amp;filter= ，第三页start条件值变成50，我们可以得出结论，每下一页，start条件值就加25。第一页start=0，第二页start=25…..第十页start=225。这样就可以循环构造网页并爬取了. 另一种思路：网页不是有下一页的按钮吗，右键检查一下，发现它已经包含了要构造的部分了，是一个属性值，提取出来接到原网址上即得到下一页的网址，这样能完全爬取所有页数，不用像上面一样设置循环次数。 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import requestsfrom bs4 import BeautifulSoupurl = 'https://movie.douban.com/top250'with open('douban.txt','w',encoding='utf-8') as f: while url : headers = &#123;'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36'&#125; r=requests.get(url,headers=headers) soup = BeautifulSoup(r.text,'lxml') for each in soup.find_all('div',class_='info'): img_url = each.previous_sibling.previous_sibling.a.img['src'] title=each.find('div',class_='hd').get_text(strip=True).replace('\xa0','') actor = list(each.find('p',class_='').strings)[0].strip().replace('\xa0','') #将生成器list化后索引，strip()去除两边空格再用空字符替换&amp;nbsp type_ = list(each.find('p',class_='').strings)[1].strip().replace('\xa0','') score = each.find('div',class_='star').get_text('/',strip=True) if each.find('span',class_='inq'):#注意有部电影没有总结，也就没有&lt;span class="inq"&gt;标签这里用if检测一下防止None使用string方法报错 quote = each.find('span', class_='inq').string else: quote = '没有总结哦' f.write(img_url+'\n'+title+'\n'+actor+'\n'+type_+'\n'+score+'\n'+quote+'\n') f.write('\n') try:#到最后一页时没有下一页按钮，会报TypeError，这时用try语句让url=None使while循环停止 url = 'https://movie.douban.com/top250' + soup.find('span',class_='next').a['href'] except TypeError: url = None]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习爬虫Part1]]></title>
    <url>%2F2019%2F05%2F04%2FStudyPachong1%2F</url>
    <content type="text"><![CDATA[爬虫思路&amp;requests模块使用 爬虫思路：我们平时是如何上网的，大概就是这样： ①点开目标网址→→[可选：登录/回复]→→②浏览全页筛选出价值内容→→③如果很喜欢，还会拷贝下载回来 所以爬虫归结起来也就这几步： 构造目标网址（重点）发起请求（request），相当于点开网页。获取网页内容（坑）。定制筛选器，对内容进行筛选（重点）。把爬取结果保存到容器里。 F12审查元素：这是浏览器自带的工具，提供抓包和检查网页源码的功能，供使用者分析网页。也是学爬虫必须要学会的工具。 使用非常简单，打开任一浏览器（google chrome），按F12或鼠标右键检查。 选择Element是查看网页源码，是树结构的html文档，里面有要爬取的内容。选择Network是查看本地和服务器端交互的包，可以从中获取目标网址和headers。 requests模块：简单使用：主要介绍两种方法：get和post get，就是本地向服务器索取的意思，服务器检查请求头（request headers）后，如果觉得没问题，就会返回信息给本地。1r = requests.get(url,**args)#返回一个Response对象，我们可以从这个对象中获取所有我们想要的信息 post，就是本地要向服务器提交一些数据的意思，服务器还是会检查请求头，如果提交的数据和请求头都没问题，就会返回信息给本地。1r = requests.post(url,**args)#也是返回Response对象 参数详解get和post方法中有许多参数可以使用。 url：就是目标网址，接收完整（带http）的地址字符串。headers：请求头，存储本地信息如浏览器版本，是一个字典。data：要提交的数据，字典。cookies：cookies，字典。timeout：超时设置，如果服务器在指定秒数内没有应答，抛出异常，用于避免无响应连接，整形或浮点数。params：为网址添加条件数据，字典。123payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get("http://httpbin.org/get", params=payload)#相当于目标网址变成了http://httpbin.org/get?key2=value2&amp;key1=value1 proxies：ip代理时使用，字典。 Response对象使用从这个对象中获取所有我们想要的信息非常简单，毕竟爬虫要的数据主要就三种，html源码，图片二进制数据，json数据，Response对象一次性满足你三个愿望。 1234r.encoding = 'ISO-8859-1' #指定r.text返回的数据类型，写在r.text之前。 r.text #默认以unicode形式返回网页内容，也就是网页源码的字符串。 r.content #以二进制形式返回网页内容，下载图片时专用。 r.json() #把网页中的json数据转成字典并将其返回。 还有一些很少用到的方法。r.headers #返回服务器端的headers，字典。r.status_code #返回连接状态，200正常。 小实例requests 学完后就可以到处试试了.12345import requestsr = requets.get('http://cn.python-requests.org/zh_CN/latest/')with open('test.txt','w',encoding = 'utf-8') as file:#编码要对应 file.write(r.text) #然后打开看看吧，是不是和F12看到的源码一样，只不过是把分支全展开了而已。 小提示：并不是所有网站的F12源码和爬取源码是一致的，网站有动态的，也有静态的；有防爬虫的，也有敞开大门任意爬的。 爬虫伪装&amp;反“反爬”有些网站是防爬虫的。总的来说有两种反爬策略，要么验证身份，把虫子踩死在门口；要么在网站植入各种反爬机制，让爬虫知难而退。 身份伪装自定制 Requests Headers 修改user-agent：里面储存的是系统和浏览器的型号版本，通过修改它来假装自己是人。 修改referer：告诉服务器你是通过哪个网址点进来的而不是凭空出现的，有些网站会检查。 带上cookie，有时带不带饼干得到的结果是不同的，试着带饼干去“贿赂”服务器让她给你完整的信息。 详细数据可以F12捉个包来查看其Requests Headers 12345headers = &#123;'Referer':'https://accounts.pixiv.net/loginlang=zh&amp;source=pc&amp;view_type=page&amp;ref=wwwtop_accounts_index',#如某些网站（如p站）要检查referer，就给他加上'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36'#每个爬虫必备的伪装 &#125;r = requests.get("https://segmentfault.com/a/1190000014383966",headers=headers) headers数据通常用这两个即可，而且强烈推荐在爬虫中为每个request都配个user-agent，总比什么都没有好，加了也不会报错。 降低主IP访问频率注意：这是针对长期的，大范围的爬虫的 有些网站会监视某个ip的访问频率和次数，一但超过某个阈值，就把你当作爬虫嫌犯赶出去了，这时就要想办法降低自己的存在感了。 休眠：爬一段时间后休息一会，不仅是为了自己的成功，也是为服务器着想。 ip代理：通过proxies参数来使用，前提是你要有ip，好的ip代理是要花钱的。 1234time.sleep(60)#用python自带time模块的休眠功能proxies = &#123;'http': 'http://10.10.1.10:3128',#“协议类型：完整ip地址+端号” 'https': 'http://10.10.1.10:1080'&#125;#代理ip字典，随机调用r = requests.get(url,headers=headers,proxies=proxies) 反 反爬（简析）有些时候headers伪装什么的都做足了，可还是不能如愿以偿的获得正确的网页源码，要么缺，要么给你一堆毫不相关的东西，要么干脆让你红掉。这说明要点不是伪不伪装的问题了，而是如何去解读网页的防爬机制从而推出解决方法。 就我目前遇到的主要有： 随机校验码：网页生成随机码，并要求你将其提交才接受你的请求（多用在登录验证中）。——这种校验码通常藏在网页源码中，先取再交是策略。无序网址：网址后跟着一大串看不出规律的东西。——跟这种东西是没话说的，直接上selenium。加密/杂乱的源码：你知道你要的东西就在那里，但是不知道怎样提取出来。——推理解谜，看脑子好不好使了。动态加载：需要和页面交互才能获取更多信息，但是爬虫没法和它交互啊。——直接上selenium/手动捉包分析出目标链接ajax技术：异步加载，网页内容分次加载，用爬虫只能得到第一次发出的html，导致信息不全。——上selenium/手动捉包分析出目标连接补充：selenium模块，模拟浏览器，强是强但是缺点是慢。其实动态加载是为了方便用户点哪看哪的，但这也加大了爬虫的难度，因为很多信息因此被隐藏了起来。 BeautifulSoup解析网页观察html，定制筛选器。 BeautifulSoup把html文档转换为可定位的树结构，并提供索引，查找，修改功能。 标签索引Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是一个对象,所有对象可以归纳为4种: Tag(标签) , NavigableString(字符串), BeautifulSoup(汤) , Comment(注释) , 知道就行. BeautifulSoup类接收2个参数，第一个是html文档，第二个是解释器名，不写的话会自动选择。实例化后生成树结构，这里顺便附上各种解释器比较 123from bs4 import BeautifulSoup#注意不是直接导入beautifulsoup4r = requests(......)soup = BeautifulSoup(r.text,"html.parser") Tag（标签）类，包含该标签的所有内容，有多种方法用于索引元素/获取字符串（下面的tag，tag1指的是标签名）soup相当于最大的Tag对象。 定位：标签定位，previous_sibling/next_sibling 1234tag2 = soup.tag1.tag2#定位到tag1下的tag2，并将其返回tag4 = tag2.tag3.tag4，#标签对象可以继续向下定位brother_tag = tag.previous_sibling/next_sibling#定位到该tag的上一个/下一个兄弟标签并将其返回brother_tag = tag.previous_siblings/next_siblings#返回的是生成器，内含多个兄弟标签。 索引： attrs,中括号索引 12dict1 = tag.attrs #以字典形式返回该tag下的元素及其对应值lang = tag["lang"] #返回该tag下的lang属性的值，和字典索引用法一样 获取字符串： string,strings,get_text() 1234567string = tag.string #仅限于夹在该tag的字符串，不包子的字符串，将每段字符串无缝连接后返回。#如对`&lt;a&gt;A1&lt;b&gt;BB&lt;/b&gt;A2&lt;c&gt;CC&lt;/c&gt;A3&lt;d&gt;DD&lt;/d&gt;A4&lt;/a&gt;`使用a.string返回的是"A1A2A3A4"strings = tag.strings #以生成器形式返回该tag下（**不包括子**）的**每段字符串**,供for循环使用。strings = tag.stripped_strings #来先去除空行/空格再返回生成器text = tag.get_text(分隔符,strip=False) #返回该tag下(包括所有子孙)的字符串，同一个tag下的字符串无缝连接，不同tag下字符串间以指定分隔符连接,strip默认为False，改为True时自动去除空行/空格。 以上的方法都是单次定位的，如果有多个符合标准的定位则以出现的第一个为准！！！ 索引和获取字符串的方法一定是最后用的，因为它不再返回Tag对象！！！ find_all&amp;find方法它们能实现某个范围内的条件定位（不通过父子兄弟关系）,返回Tag对象供使用各种索引方法。 find()的作用是实现范围内的单次条件定位 find_all()的作用是以可迭代的形式返回范围内多个符合要求的定位，但是你要确保这个标签对你要的信息具有唯一性。 信息有时是分块的，这时定位也应分块，再对每个分块使用单次定位，下面是一个最常用的筛选器。 1234for each in soup.find_all(.......):#通常第一句就是用find_all进行分块 string = each.find().string #然后在该分块中使用条件定位，再使用索引方法 id = each.find()['id'] ........ find和find_all接收的参数是一样的，现以find_all为例：Tag.find_all(name,attrs,recursive,limit,text,*kwards) name：标签名，定位到指定标签名的节点如’a’想匹配多种标签名可传列表如[‘div’,’a’,’b’]想自定标签名规则可传正则表达式如re.compile(规则) **kwards：其实是标签里的属性及其值，定位到有指定属性，属性值的标签,如.find_all(lang=’en’) 如果属性叫class，为防止与类的“class”冲突要在后面加下横线，如.find_all(class_=’sakura’)可以设立多个条件如.find_all(class_=’sakura’,lang=’en’)属性值可以用传正则表达式如.find_all(lang=re.compile(r’’)) recursive：默认True，检索当前tag下的所有子孙标签。设置为False时只检索当前tag下的直接子标签 limit：设置匹配上限，接收自然数，决定了有效定位的数量上限。 text：搜索文档中的字符串内容，返回匹配字符串的列表，可接收字符串，字符串列表和正则表达式（这个极少用到，通常不理） ！！记得常按F12看html源码啊]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>从零开始爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http协议知识整理]]></title>
    <url>%2F2019%2F05%2F04%2Fhttp%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP 协议1.HTTP协议是什么？http协议是一个应用层的协议。规定了浏览器和服务器之间的通信规范。通常用TCP连接方式。 2.HTTP 1.0、1.1 连接的方式。 在HTTP 1.0 中，浏览器和服务器使用的是短连接，响应完，立即断开。 请求的过程：3次握手，请求，响应，断开连接。 http不保存连接，好处：服务器可以处理更多的连接，但是每次建立连接会降低处理速度。 现在主流的版本是HTTP 1.1 ，在HTTP 1.1 中我们使用长连接，一个请求结束后，不断开，继续请求。 3.HTTP协议的URLURL的格式： http://host[&quot;:&quot;port][abs_path] host: 代表主机域名或IP地址 port: 端口号，缺省端口80 abs_path : 请求资源的URL，如果没有，填 “/“，通常浏览器会帮我们自动完成。 EG: 1、输入：www.cnblogs.com 浏览器自动转换成：http://www.cnblogs.com/ 4.HTTP请求4.1 请求报文格式： HTTP的请求由3部分组成：请求行、请求头、请求体。 SP代表空格、CRLF代表换行 浏览器必须以这个格式发送请求，服务器才能正常解析和响应。 4.2 请求报文示例 4.3 请求方法GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据，常用于提交表单。 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 get和post是最常用的方法，简单来说，前者用于获取数据，后者用于提交数据。 5.HTTP响应5.1 响应报文格式：HTTP的响应也是由3个部分组成：响应行、响应头，响应体 响应行：status code 表示响应的状态码，description是描述信息。 同样 SP代表空格、CRLF代表换行， 响应必须以这种规范格式发送给浏览器，浏览器才能正常解析并显示。 5.2 响应报文示例 5.3响应码200段是成功；300段需要对请求做进一步的处理；400段表示客户端请求错误；500段是服务器的错误 常见响应码： “200” : OK “302” : Found 重定向. “400” : Bad Request 错误请求，发出错误的不符合Http协议的请求 “403” : Forbidden 禁止 “404” : Not Found 未找到。演示访问一个不存在的页面看报文 “500” : Internal Server Error 服务器内部错误。演示页面抛出异常。 “503” : Service Unavailable。一般是访问人数过多。 PS:会在文章的末尾为大家提供一份HTTP状态码大全的文档。 6.HTTP消息报头HTTP消息报头分4类：普通报头、请求报头、响应报头、实体报头 每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 6.1 普通报头应用于所有请求和响应消息且和请求体与响应体无关的信息就存放在普通报头中。 Cache-Control: no-cache （用于指示请求或响应消息不能缓存） Date 普通报头域表示消息产生的日期和时间 Connection: close/keep-alive （是否开启长连接） 6.2 请求报头客户端向服务器端传递请求的附加信息以及客户端自身的信息存放在请求报头 常用的请求报头： Accept: text/html,application/xhtml+xml,application/xml; 指定客户端接受哪些类型的信息。 Accept-Charset: iso-8859-1,gb2312 客户端接受的字符集 （缺省是任何字符集都可以接受。） Accept-Encoding: gzip,deflate,sdch 可接受的内容编码。 (缺省是各种内容编码都可以接受。) Accept-Language: zh-CN,zh 指定语言。（缺省各种语言都可以接受。） Authorization 用于证明客户端有权查看某个资源 Host: www.cnblogs.com 被请求资源的Internet主机和端口号 （缺省端口号：80） 这个报头是必需的 User-Agent: Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) 操作系统、浏览器和其它属性 6.3 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头： Location 响应报头域用于重定向接受者到一个新的位置 Server：Apache-Coyote/1.1 服务器信息 6.4 实体报头请求和响应消息都可以传送一个实体。 常用的实体报头： Content-Encoding: gzip 内容编码 Content-Language: zh-CN 语言 Content-Length: 10 实体正文的长度 Content-Type: text/html;charset=GB2312 返回数据的类型 Last-Modified 实体报头域用于指示资源的最后修改日期和时间。 Expires：Thu，15 Sep 2006 16:23:12 GMT 响应过期的日期和时间。]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>http协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http协议基础知识]]></title>
    <url>%2F2019%2F05%2F04%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP 简介HTTP 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 以下图表展示了HTTP协议通信流程： HTTP信息结构HTTP 消息结构HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。 一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。 服务器响应消息HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 实例下面实例是一点典型的使用GET来传递数据的实例： 客户端请求： GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应: HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: “34aa387-d-1568eb00”Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain 输出结果：Hello World! My payload includes a trailing CRLF. HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。 另一版本： GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP响应头信息HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 在本章节中我们将具体来介绍HTTP响应头信息。 应答头————说明 Allow：服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires：应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 HTTP状态码HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误 HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-typeContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。]]></content>
      <categories>
        <category>python</category>
        <category>学习爬虫</category>
        <category>http协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-79-Word Search]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-79%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] Given word = “ABCCED”, return true.Given word = “SEE”, return true.Given word = “ABCB”, return false. Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*’ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) dfs+回溯：1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = '*'; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-55-Jump Game]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-55%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2: Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 思路1：暴力没什么好说的，特别慢。用一个数组表示i位置是否可以达到，然后遍历数组，将所有可以达到的位置置1. 12345678910bool canJump(vector&lt;int&gt;&amp; nums) &#123; //暴力 特别慢 int sz = nums.size(); vector&lt;int&gt; jus(sz, 0); jus[0] = 1; for (int i = 0; i &lt; sz; ++i) if(jus[i]) for (int j = i + 1; j &lt;= i + nums[i] &amp;&amp; j &lt; sz; ++j) jus[j] = 1; return jus[sz - 1];&#125; 思路2：动态规划dp[i]表示前面跳到第i位置时最远还可以多跳多少。可以得到递推式：dp[i]=max( dp[i - 1], nums[i - 1] )dp[i]&lt;0表示不能跳到该位置，直接返回false.时间复杂度O(N),但空间复杂度也是O(N) 123456789101112#define MAX(A,B) (A&gt;(B)?A:B)bool canJump(vector&lt;int&gt;&amp; nums) &#123; //动态规划 8ms 99% 空间O(N) int sz = nums.size(); vector&lt;bool&gt; dp(sz, 0); for (int i = 1; i &lt; sz; ++i) &#123; dp[i] = MAX(nums[i - 1], dp[i - 1]) - 1; if (dp[i] &lt; 0) return false; &#125; return dp[sz - 1] &gt;= 0;&#125; 思路3：贪心法使用一个数reach表示目前可以达到的最远距离，当reach &gt;= sz - 1时表示可以达到最后一个位置。这个方法时间复杂度仍然是O(N)，但空间复杂度仅仅是O(1) 12345678910bool canJump(vector&lt;int&gt;&amp; nums) &#123;//贪心8ms 99% 空间O(1) int sz = nums.size(), reach = 0; for (int i = 0; i &lt; sz; ++i) &#123; if (reach &lt; i || reach &gt;= sz - 1) break; if (reach &lt; nums[i] + i) reach = nums[i] + i; &#125; return reach &gt;= sz - 1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-142-Linked List Cycle II]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-142%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Follow up:Can you solve it without using extra space? 复杂度O(n^2)的方法，使用两个指针a, b。a从表头开始一步一步往前走，遇到null则说明没有环，返回false；a每走一步，b从头开始走，如果遇到b==a.next，则说明有环true，如果遇到b==a，则说明暂时没有环，继续循环。 复杂度O(n)的方法，使用两个指针slow,fast。两个指针都从表头开始走，slow每次走一步，fast每次走两步，如果fast遇到null，则说明没有环，返回false；如果slow==fast，说明有环，并且此时fast超了slow一圈，返回true。 环的长度是多少？ 如何找到环中第一个节点（即Linked List Cycle II）？ 如何将有环的链表变成单链表（解除环）？ 如何判断两个单链表是否有交点？如何找到第一个相交的节点？ 设：链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c，如图所示。环的长度是L。slow和fast的速度分别是qs,qf。下面我们来挨个问题分析。方法一：第一次相遇后，让slow,fast继续走，记录到下次相遇时循环了几次。因为当fast第二次到达Z点时，fast走了一圈，slow走了半圈，而当fast第三次到达Z点时，fast走了两圈，slow走了一圈，正好还在Z点相遇。方法二：第一次相遇后，让fast停着不走了，slow继续走，记录到下次相遇时循环了几次。方法三：第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。 我们发现L=b+c=a+b，也就是说， 从一开始到二者第一次相遇，循环的次数就等于环的长度。 我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。 在上一个问题的最后，将c段中Y点之前的那个节点与Y的链接切断即可。 如何判断两个单链表是否有交点？先判断两个链表是否有环，如果一个有环一个没环，肯定不相交；如果两个都没有环，判断两个列表的尾部是否相等；如果两个都有环，判断一个链表上的Z点是否在另一个链表上。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; struct ListNode *fast = head; struct ListNode *slow = head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast==slow) break; &#125; if(fast==slow&amp;&amp;fast-&gt;next!=NULL) &#123; slow = head; while(slow!=fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Linked-List</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-739-Daily Temperatures]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-739%2F</url>
    <content type="text"><![CDATA[Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. 因为我们所要找的是距离最近的较大的，因此，我们从后往前，依次将索引加入到stack中，不同点在于，只要遍历到比当前栈顶元素大的，就将栈顶元素从栈中删除——因为此时栈顶元素已经不是后面的元素所距离的最近的一个，较大的元素了。因此，栈顶的元素所保存的，一直都是目前来说，索引值最小的当前最大元素的索引。因此，利用这种办法，直接从后往前就可以分别对这些距离进行计算了。 从后往前，如果当前i对应的元素大于stack的top那么就pop掉这个top，一直循环，最后stack要么为空，要么不为空，为空，则为0，不为空则为top对应的i-top减去当前iWhen i = 7, stack = [7 (73)]. ans[i] = 0.When i = 6, stack = [6 (76)]. ans[i] = 0.When i = 5, stack = [5 (72), 6 (76)]. ans[i] = 1.When i = 4, stack = [4 (69), 5 (72), 6 (76)]. ans[i] = 1.When i = 3, stack = [3 (71), 5 (72), 6 (76)]. ans[i] = 2.When i = 2, stack = [2 (75), 6 (76)]. ans[i] = 4.When i = 1, stack = [1 (74), 2 (75), 6 (76)]. ans[i] = 1.When i = 0, stack = [0 (73), 1 (74), 2 (75), 6 (76)]. ans[i] = 1. 如果对于这类，到当前元素最近XX等的问题，利用栈的先进后出的性质来进行求解是一种比较可取的办法。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; res (n, 0); stack&lt;int&gt; s; for(int i = n-1;i&gt;=0;i--) &#123; while(!s.empty() &amp;&amp; temperatures[i] &gt;= temperatures[s.top()]) s.pop(); if(!s.empty()) res[i] = s.top() - i; s.push(i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Stack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-221-Maximal Square]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-221%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.Example: Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Output: 4 To apply DP, we define the state as the maximal size (square = size * size) of the square that can be formed till point (i, j), denoted as dp[i][j]. For the topmost row (i = 0) and the leftmost column (j = 0), we have dp[i][j] = matrix[i][j] - ‘0’, meaning that it can at most form a square of size 1 when the matrix has a ‘1’ in that cell. When i &gt; 0 and j &gt; 0, if matrix[i][j] = ‘0’, then dp[i][j] = 0 since no square will be able to contain the ‘0’ at that cell. If matrix[i][j] = ‘1’, we will have dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1, which means that the square will be limited by its left, upper and upper-left neighbors. dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1: 约束该点最大方形面积的三个因素： 左边延申的距离， 上面延申的距离， 左上延申的距离（对角线） 123456789101112131415161718192021 class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; dp[i][j] = matrix[i][j] - '0'; &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; sz = max(dp[i][j], sz); &#125; &#125; return sz * sz; &#125;&#125;; In the above code, it uses O(mn) space. Actually each time when we update dp[i][j], we only need dp[i-1][j-1], dp[i-1][j] (the previous row) and dp[i][j-1] (the current row). So we may just keep two rows. 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;int&gt; pre(n, 0), cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); &#125; fill(pre.begin(), pre.end(), 0); swap(pre, cur); &#125; return sz * sz; &#125;&#125;; Furthermore, we may only use just one vector 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0, pre; vector&lt;int&gt; cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int temp = cur[j]; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); pre = temp; &#125; &#125; return sz * sz; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode-236%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the binary tree.Accepted 我们在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，我们可以用递归来实现，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 1）若p和q要么分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。 2）若p和q同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。 3）若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if( root == nullptr or root == p or root == q ) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor( root-&gt;left, p, q ); TreeNode* right = lowestCommonAncestor( root-&gt;right, p, q ); if( left == nullptr ) &#123; return right; &#125; if( right == nullptr ) &#123; return left; &#125; return root; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top-100-liked-questions</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pytorch库实现动图线性回归]]></title>
    <url>%2F2019%2F05%2F03%2Fpython%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92gif%2F</url>
    <content type="text"><![CDATA[python代码：1234567891011121314151617181920212223242526272829303132333435363738import torchimport torch.nn as nnimport matplotlib.pyplot as pltimport imageiotorch.manual_seed(0)num_samples = 100x_train = torch.linspace(0, 1, num_samples)y_train = 0.1 * x_train + 0.2 + torch.randn(num_samples)*0.03w = torch.randn(1, requires_grad=True)b = torch.randn(1, requires_grad=True)criterion = nn.MSELoss()optimizer = torch.optim.SGD([w,b], lr=0.01)images = []num_epochs = 4000for epoch in range(num_epochs): y_pred = w * x_train + b loss = criterion(y_pred, y_train) optimizer.zero_grad() loss.backward() if epoch % 100 == 99: plt.figure() plt.ylim(torch.min(y_train).item(), torch.max(y_train).item()) plt.scatter(x_train.tolist(), y_train.tolist(), marker='.') plt.plot(x_train.tolist(), y_pred.tolist(), color='r', linewidth=2) plt.title('Epoch [&#123;&#125;/&#123;&#125;], Loss: &#123;:.6f&#125;, \n Weight: &#123;:.6f&#125;, Bias: &#123;:.6f&#125;' .format(epoch+1, num_epochs, loss.item(), w.item(), b.item())) plt.savefig('a.png') plt.close() images.append(imageio.imread('a.png')) optimizer.step() imageio.mimsave('gen.gif', images, duration=0.5) 效果图：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PyTorch库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用PIL库进行gif图的解析或合成]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create1%2F</url>
    <content type="text"><![CDATA[那个星夜越过千年而我绕过半个地球重新来寻那个你那个亮尽我的眼的你一颗流星划过坠入无边黑暗你等我一千年我找你十万里——《星空》湮夫跨界艺术家插画师James R. Eads的画作，似乎一下子游离到了另一个世界。在他的笔下，一个个创思化身成一个个闪光的光点，五彩缤纷，随意萦绕，勾勒出一个个美轮美奂的画境，似有阳光的热烈，也有月光的浪漫，更有浩瀚星光似的唯美与空明，让人很容易就沉浸在这美妙的小宇宙中。 受梵高的绘画风格影响，他巧妙地将色彩与富有动感的笔触结合起来，使画面梦幻而富有冲击力。神秘缤纷的色彩、浩瀚如宇宙的笔触，自然与人就这样被James R. Eads用独特的绘画方法结合在一起，启发著人们去思考人与人、人与自然之间的关系。 欣赏作品： 我们尝试利用PIL库将gif图进行解析， 然后再重新合成gif图， 并改变帧的变化速率。 解析gif图代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#-*- coding: UTF-8 -*- import osfrom PIL import Image def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print ("saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile)) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def main(): processImage('1.gif') if __name__ == "__main__": main() 合成gif图代码：12345678910111213141516171819202122#-*- coding: UTF-8 -*- import imageio def create_gif(image_list, gif_name): frames = [] for image_name in image_list: frames.append(imageio.imread(image_name)) # Save them as frames into a gif imageio.mimsave(gif_name, frames, 'GIF', duration = 0.1) return def main(): image_list = ['1-0.png', '1-2.png', '1-4.png', '1-6.png', '1-8.png', '1-10.png'] gif_name = 'created_gif1.gif' create_gif(image_list, gif_name) if __name__ == "__main__": main() 某gif图解析后部分图片如下： gif图合成后：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PIL库里的基本知识概念]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create%2F</url>
    <content type="text"><![CDATA[首先，介绍一下PIL中的基本概念。PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。 1、 通道每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 方法getbands()的使用如下：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.getbands()('R', 'G', 'B')&gt;&gt;&gt;im_bands = im.getbands()&gt;&gt;&gt;len(im_bands)3&gt;&gt;&gt;print im_bands[0]R&gt;&gt;&gt;print im_bands[1]G&gt;&gt;&gt;print im_bands[2]B 2、 模式图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： 1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用如下：12345678&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;md = im.mode&gt;&gt;&gt;print mdRGB 3、 尺寸通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性mode的使用如下：1234567891011&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_size = im.size&gt;&gt;&gt;print im_size[0]800&gt;&gt;&gt;print im_size[1]450 4、 坐标系统PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 5、 调色板调色板模式 (“P”)使用一个颜色调色板为每个像素定义具体的颜色值 6、 信息使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 属性info的使用如下：1234567891011121314&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im_info = im.info&gt;&gt;&gt;im_info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;print im_info['jfif_version'](1, 1)&gt;&gt;&gt;print im_info['jfif']257 7、 滤波器对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为：resize(size, filter=None)=&gt; image12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_resize = im.resize((256,256))&gt;&gt;&gt;im_resize.size(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011&gt;&gt;&gt;im_resize0 = im.resize((256,256), Image.BILINEAR)&gt;&gt;&gt;im_resize0.size(256, 256)&gt;&gt;&gt;im_resize1 = im.resize((256,256), Image.BICUBIC)&gt;&gt;&gt;im_resize1.size(256, 256)&gt;&gt;&gt;im_resize2 = im.resize((256,256), Image.ANTIALIAS)&gt;&gt;&gt;im_resize2.size(256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None)12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200))&gt;&gt;&gt;im.size(200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011121314151617181920212223&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200),Image.BILINEAR)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.BICUBIC)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.ANTIALIAS)&gt;&gt;&gt;im.size(200, 112) 接着，说说PIL中的Image模块Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。 一、Image类的属性1、 Format定义：im.format ⇒ string or None 含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。 例子：12345678910&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.format'JPEG'注：test.jpg是JPEG图像，所以其文件格式为JPEG。&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.format'GIF'注：test.gif为GIF文件，所以其文件格式为GIF。 2、 Mode定义：im.mode ⇒ string 含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P' 3、 Size定义：im.size ⇒ (width, height) 含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt; im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt; im.size(400, 220) 4、 Palette定义：im.palette ⇒ palette or None 含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 例子：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im.palette&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P'&gt;&gt;&gt;im.palette&lt;PIL.ImagePalette.ImagePaletteobject at 0x035E7AD0&gt;&gt;&gt;&gt;pl= im.palettePl为ImagePalette类的实例。 5、 Info定义：im.info ⇒ dictionary 含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.info&#123;'duration':100, 'version': 'GIF89a', 'extension': ('NETSCAPE2.0', 795L), 'background': 0,'loop': 0&#125; 二、Image类的函数1、 New定义：Image.new(mode,size) ⇒ image Image.new(mode, size, color) ⇒ image 含义：使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 例子：123456789101112&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "#FF0000")&gt;&gt;&gt;im.show()图像im为128x128大小的红色图像。&gt;&gt;&gt;im= Image.new("RGB", (128, 128))&gt;&gt;&gt;im.show()图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "red")&gt;&gt;&gt;im.show图像im为128x128大小的红色图像。 2、 Open定义：Image.open(file) ⇒ image Image.open(file, mode) ⇒ image 含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。 用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 例子：123456&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg", "r")&gt;&gt;&gt;im.show() 3、 Blend定义：Image.blend(image1,image2, alpha) ⇒ image 含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;im =Image.blend(im01, im02, 0.3)&gt;&gt;&gt;im.show() Test01.jpg和test02.jpg两张图像size都为1024x768，mode为“RGB”。它们按照第一张70%的透明度，第二张30%的透明度，合成为一张。 4、 Composite定义：Image.composite(image1,image2, mask) ⇒ image 含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;g.mode'L'&gt;&gt;&gt; g.size(1024, 768)&gt;&gt;&gt;im= Image.composite(im01, im02, g)&gt;&gt;&gt;im.show() 5、 Eval定义：Image.eval(image,function) ⇒ image 含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;def fun(x): return x * 0.5&gt;&gt;&gt;im_eval = Image.eval(im01, fun)&gt;&gt;&gt;im_eval.show()&gt;&gt;&gt;im01.show() 图像im01如下图： 图像im_eval如下图： 图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。 6、 Frombuffer定义：Image.frombuffer(mode,size, data) ⇒ image Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image 含义：（New in PIL 1.1.4）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。 注意：版本1.1.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示：123im=Image.frombuffer(mode, size, data, "raw", mode, 0, 1)函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。 7、 Fromstring定义：Image.fromstring(mode,size, data) ⇒ image Image.fromstring(mode, size,data, decoder, parameters) ⇒ image 含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。 函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder. 注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。 8、 Merge定义：Image.merge(mode,bands) ⇒ image 含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) 例子：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 = Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r1,g1,b1 = im01.split()&gt;&gt;&gt;r2,g2,b2 = im02.split()&gt;&gt;&gt;r1.mode'L'&gt;&gt;&gt;r1.size(1024, 768)&gt;&gt;&gt;g1.mode'L'&gt;&gt;&gt;g1.size(1024, 768)&gt;&gt;&gt;r2.mode'L'&gt;&gt;&gt;g2.size(1024, 768)&gt;&gt;&gt;imgs=[r1,g2,b2]&gt;&gt;&gt;len(ImageMode.getmode("RGB").bands)3&gt;&gt;&gt;len(imgs)3&gt;&gt;&gt;im_merge = Image.merge("RGB", imgs)&gt;&gt;&gt;im_merge.show() 三、Image类的方法除非另作说明，Image类的所有方法都将返回一个Image类的新实例，这个实例对应于结果图像。 1、 Convert定义1：im.convert(mode)⇒ image 含义1：将当前图像转换为其他模式，并且返回新的图像。 当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。 当从一个颜色图像转换为黑白图像时，PIL库使用ITU-R601-2 luma转换公式： L = R 299/1000 + G 587/1000 + B * 114/1000 当转换为2位图像（模式“1”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。为了去掉图像抖动现象，可以使用dither选项。 例子1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im_c = im01.convert("L")&gt;&gt;&gt;im_c.mode'L'将“RGB”模式的im01图像，转换为“L”模式的im_c图像。定义2：im.convert(“P”,**options) ⇒ image含义2：这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：Dither=. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。Palette=. 控制调色板的产生。默认是WEB，这是标准的216色的“web palette”。要使用优化的调色板，则赋值为ADAPTIVE。Colors=. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色。例子2： 定义3：im.convert(mode,matrix) ⇒ image含义3：使用转换矩阵将一个“RGB”图像转换为“L”或者“RGB”图像。变量matrix为4或者16元组。例子3：下面的例子将一个RGB图像（根据ITU-R709线性校准，使用D65亮度）转换到CIE XYZ颜色空间：&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;rgb2xyz = ( 0.412453,0.357580, 0.180423, 0, 0.212671,0.715160, 0.072169, 0, 0.019334,0.119193, 0.950227, 0 ) &gt;&gt;&gt;im_c3 = im01.convert("L", rgb2xyz)&gt;&gt;&gt;im_c3.show()&gt;&gt;&gt;im_c3.mode'L' 2、 Copy定义：im.copy() ⇒ image 含义：拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。 例子：123&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_copy = im01.copy() 图像im_copy和im01完全一样。 3、 Crop定义：im.crop(box) ⇒ image 含义：从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。 这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box= [0, 0, 100, 100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im_crop.size(100, 100) 4、 Draft定义：im.draft(mode,size) 含义：配置图像文件加载器，使得返回一个与给定的模式和尺寸尽可能匹配的图像的版本。例如，用户可以使用这个方法，在加载一个彩色JPEG图像时将其转换为灰色图像，或者从一个PCD文件中提取一个128x192的版本。 注意：这个方法会适时地修改图像对象（精确地说，它会重新配置文件的读取器）。如果图像已经被加载，那这个方法就没有作用了。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.draft("L", (100,100))&lt;PIL.JpegImagePlugin.JpegImageFileimage mode=L size=128x96 at 0x3B69230&gt;&gt;&gt;&gt;im01.size(128, 96)&gt;&gt;&gt;im01.mode'L' 5、 Filter定义：im.filter(filter) ⇒ image 含义：返回一个使用给定滤波器处理过的图像的拷贝。可用滤波器需要参考ImageFilter模块。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_filter = im01.filter(ImageFilter.BLUR)&gt;&gt;&gt;im_filter.show() 图像im_filter比im01变得有些模糊了。 6、 Fromstring定义：im.fromstring(data) im.fromstring(data, decoder,parameters) 含义：与函数fromstring()一样，但是这个方法会将data加载到当前的图像中。 7、 Getbands定义：im.getbands()⇒ tuple of strings 含义：返回包括每个通道名称的元组。例如，对于RGB图像将返回（“R”，“G”，“B”）。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbands()('R', 'G', 'B') 8、 Getbbox定义：im.getbbox() ⇒ 4-tuple or None 含义：计算图像非零区域的包围盒。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbbox()(0, 0, 1024,768) 9、 Getcolors定义：im.getcolors() ⇒ a list of(count, color) tuples or None im.getcolors(maxcolors) ⇒ a list of (count, color) tuples or None 含义：（New in 1.1.5）返回一个（count，color）元组的无序list，其中count是对应颜色在图像中出现的次数。 如果变量maxcolors的值被超过，该方法将停止计算并返回空。变量maxcolors默认值为256。为了保证用户可以获取图像中的所有颜色，you can pass in size[0]*size[1]（请确保有足够的内存做这件事）。 例子：12345678910111213141516171819202122232425&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getcolors()&gt;&gt;&gt;im01.getcolors(256)&gt;&gt;&gt;ls= im01.getcolors(255)&gt;&gt;&gt;len(ls) Traceback (mostrecent call last): File "&lt;pyshell#201&gt;", line 1,in &lt;module&gt; len(ls)TypeError:object of type 'NoneType' has no len() 不知道为什么图像im01.getcolors()返回为空，这个后续需要进一步研究。 10、 Getdata定义：im.getdata() ⇒ sequence 含义：以包含像素值的sequence对象形式返回图像的内容。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。 注意：这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用list(im.getdata())，将它转换为普通的sequence。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;seq= im01.getdata()&gt;&gt;&gt;seq0 = list(seq)&gt;&gt;&gt;seq[0](11, 113, 198)&gt;&gt;&gt;seq[2](9, 111, 196)&gt;&gt;&gt;seq0[0](11, 113, 198)&gt;&gt;&gt;seq0[2](9, 111, 196)Sequence对象的每一个元素对应一个像素点的R、G和B三个值。 11、Getextrema定义：im.getextrema() ⇒ 2-tuple 含义：返回一个2元组，包括该图像中的最小和最大值。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getextrema()((0, 255), (0,255), (0, 255))该方法返回了R/G/B三个通道的最小和最大值的2元组。 12、Getpixel定义：im.getpixel(xy) ⇒ value or tuple 含义：返回给定位置的像素值。如果图像为多通道，则返回一个元组。 注意：该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.getpixel((1,1))(10, 112, 197)&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.getpixel((0,0))11 13、Histogram定义1：im.histogram()⇒ list 含义1：返回一个图像的直方图。这个直方图是关于像素数量的list，图像中的每个像素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值）。 二值图像（模式为“1”）当作灰度图像（模式为“L”）处理。 例子1：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;ls= im01.histogram()&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]359&gt;&gt;&gt;ls[256]295&gt;&gt;&gt;ls[767]109953图像im01为RGB图像，所以有768项。 定义2：im.histogram(mask)⇒ list 含义2：返回图像中模板图像非零地方的直方图。模板图像与处理图像的尺寸必须相同，并且要么是二值图像（模式为“1”），要么为灰度图像（模式为“L”）。 例子2：123456789101112131415161718&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;ls= im01.histogram(r)&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]0&gt;&gt;&gt;ls[256]248&gt;&gt;&gt;ls[767]109953 14、Load定义：im.load() 含义：为图像分配内存并从文件中加载它（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。 （New in 1.1.6）在1.1.6及以后的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如： pix = im.load() print pix[x, y] pix[x, y] =value 通过这个对象访问比方法getpixel()和putpixel()快很多。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;pix= im01.load()&gt;&gt;&gt;pix[0,0](11, 113, 198) 15、Offset定义：im.offset(xoffset,yoffset) ⇒ image 含义：（不赞成）返回按照给定位置的偏移对应的图像的拷贝。数据延续到图像的边缘。如果变量yoffset没有赋值，将假设其与变量xoffset一样。 不赞成使用这个方法，在PIL 1.2版本中去掉该方法。新的代码将使用ImageChops模块中的offset()函数。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;img= im01.offset(1,1) Traceback (mostrecent call last): File "&lt;pyshell#38&gt;", line 1,in &lt;module&gt; img = im01.offset(1,1) File"C:\Python27\lib\site-packages\PIL\Image.py", line 1246, in offset "Please call ImageChops.offset()instead.")Exception:offset() has been removed. Please call ImageChops.offset() instead.由此可见，该版本中已经去掉了方法offset()。 16、 Paste定义1：im.paste(image,box) 含义1：将一张图粘贴到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。 如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。 例子1：1234567891011121314151617181920212223&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box=[0,0,100,100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.size(100, 100)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im01.paste(im_crop, (200,200))&gt;&gt;&gt;im01.paste(im_crop, (500,500,600,600))&gt;&gt;&gt;im01.show()我们先从图像im01中裁剪出一个100x100的图像，它的模式与im01一样都是“RGB”。然后通过2元组和4元组的方式，将裁剪出来的图像粘贴到图像im01上。在图像im01的（200，200）和（500，500）两个位置分别出现了裁剪出来的100x100的图像。其结果如下图所示： 定义2：im.paste(colour,box) 含义2：它与定义1一样，但是它使用同一种颜色填充变量box对应的区域。对于单通道图像，变量colour为单个颜色值；对于多通道，则为一个元组。 例子2：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;im01.paste((0,256,0),(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的绿色方块。 &gt;&gt;&gt;im01.paste(255,(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的红色方块。对于多通道的图像，如果变量colour只给定一个数值，将只会应用于图像的第一个通道。如果是“RGB”模式的图像，将应用于红色通道。 定义3：im.paste(image,box, mask) 含义3：与定义1一样，但是它使用变量mask对应的模板图像来填充所对应的区域。可以使用模式为“1”、“L”或者“RGBA”的图像作为模板图像。模板图像的尺寸必须与变量image对应的图像尺寸一致。如果变量mask对应图像的值为255，则模板图像的值直接被拷贝过来；如果变量mask对应图像的值为0，则保持当前图像的原始值。变量mask对应图像的其他值，将对两张图像的值进行透明融合。 注意：如果变量image对应的为“RGBA”图像，即粘贴的图像模式为“RGBA”，则alpha通道被忽略。用户可以使用同样的图像作为原图像和模板图像。 例子3：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box =[500,500,600,600]&gt;&gt;&gt;im_crop =im01.crop(box)&gt;&gt;&gt;r,g,b =im_crop.split()&gt;&gt;&gt;im01.paste(im_crop, (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个半透明的100x100的方块。 定义4：im.paste(colour,box, mask) 含义4：与定义3一样，只是使用变量colour对应的单色来填充区域。 例子4：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;box= [500,500,600,600]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;r,g,b = im_crop.split()&gt;&gt;&gt;im01.paste((0,256,0), (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个100x100的绿色方块。 17、 Point定义1：im.point(table)⇒ image im.point(function) ⇒ image 含义1：返回给定查找表对应的图像像素值的拷贝。变量table为图像的每个通道设置256个值。如果使用变量function，其对应函数应该有一个参数。这个函数将对每个像素值使用一次，结果表格将应用于图像的所有通道。 如果图像的模式为“I（整数）”或者“F（浮点）”，用户必须使用function方式，function必须按照下面的格式： argument * scale+ offset 例如： out = im.point(lambda i: i * 1.2 + 10) 用户可以省略变量scale和offset。 例子1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_point_fun = im01.point(lambda i:i*1.2+10)&gt;&gt;&gt;im_point_fun.show()图像im_point_fun比原图im01亮度增加了很多；因为lambda表达式中对原图的每个像素点的值都做了增加操作。Lambda表达式是python中可以替代简单函数的一种方式，它只能封装有限的逻辑，但是对于某些情况，使用起来还是很方便的。定义lambda函数的形式如下：labmda参数：表达式lambda函数默认返回表达式的值。你也可以将其赋值给一个变量。lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。Lambda表达式的例子：&gt;&gt;&gt;range(10)[0, 1, 2, 3, 4,5, 6, 7, 8, 9]如果我们要对这10个数字，逐个做加一操作，可以使用如下表达式：&gt;&gt;&gt;map(lambda x:x+1, [y for y in range(10)])[1, 2, 3, 4, 5,6, 7, 8, 9, 10]函数map()是python的内置函数，其格式如下：map( func,seq1[, seq2...]Python函数式编程中的map()函数是将func作用于seq中的每一个元素，并用一个列表给出返回值。如果func为None，作用同zip()。当seq只有一个时，将func函数作用于这个seq的每个元素上，得到一个新的seq。例如：&gt;&gt;&gt;map(lambda x:x+10, range(10))[10, 11, 12, 13,14, 15, 16, 17, 18, 19]当seq多于一个时，map可以并行地对每个seq执行。每个seq的同一位置的元素在执行过一个多元的func函数之后，得到一个返回值，这些返回值放在一个结果列表中。需要注意的是，不同长度的多个seq是无法执行map函数的，会出现类型错误。例如：&gt;&gt;&gt;map(lambda x,y:x+y, [1,2,3],[4,5,6])[5, 7, 9]func是None的情况，它的目的是将多个列表相同位置的元素归并到一个元组，在现在已经有了专用的函数zip()了。例如：&gt;&gt;&gt;map(None, [1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip([1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。例如：&gt;&gt;&gt; a =[1,2,3]&gt;&gt;&gt; b =[2,3,4]&gt;&gt;&gt; b =[4,5,6]&gt;&gt;&gt; c =[4,5,6,7,8]&gt;&gt;&gt;zipped = zip(a,b)&gt;&gt;&gt;zipped[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(a,c)[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(*zipped)[(1, 2, 3), (4,5, 6)]定义2：im.point(table,mode) ⇒ imageim.point(function, mode) ⇒ image 含义2：与定义1一样，但是它会为输出图像指定一个新的模式。这个方法可以一步将模式为“L”和“P”的图像转换为模式为“1”的图像。 （New in 1.1.5）这个方法也可以将“L”图像转换为“I”和“F”模式，或者将16 位的“I”模式图像转换为“L”模式，此时必须使用65536项的查找表。 例子2：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt; im= r.point(lambda x:x*1.3+5, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))19图像im为全白图；&gt;&gt;&gt; im= r.point(lambda x:1, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))1图像im为全白图；&gt;&gt;&gt;im= r.point(lambda x:x*0, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))0图像im为全黑图； 18、 Putalpha定义：im.putalpha(band) 含义：将给定的通道拷贝到图像的alpha层。此处的图像模式必须为“RGBA”，变量band必须为“L”或者“1”。 （New in PIL 1.1.5）方法putalpha()也可以用于其他模式；图像原地转换为有alpha通道的模式（通常转换为“LA”或者“RGBA”）。变量band要么为图像，要么为颜色值（一个整数）。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.putalpha(100)&gt;&gt;&gt;im01.mode'RGBA'&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198,100) 19、 Putdata定义：im.putdata(data) im.putdata(data, scale, offset) 含义：从sequence对象中拷贝数据到当前图像，从图像的左上角（0，0）位置开始。变量scale和offset用来调整sequence中的值： pixel = value *scale + offset 如果变量scale忽略，则默认为1.0。如果变量offset忽略，则默认为0.0。 例子：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; r,g,b =im01.split()&gt;&gt;&gt;r.getpixel((0,0))11&gt;&gt;&gt;r.getpixel((1,0))10&gt;&gt;&gt;r.getpixel((2,0))9&gt;&gt;&gt;r.getpixel((3,0))6&gt;&gt;&gt;r.putdata([1,2,3,4])&gt;&gt;&gt;r.getpixel((0,0))1&gt;&gt;&gt;r.getpixel((1,0))2&gt;&gt;&gt;r.getpixel((2,0))3&gt;&gt;&gt;r.getpixel((3,0))4 20、 Putpalette定义：im.putpalette(sequence) 含义：为“P”或者“L”图像增加一个调色板。对于“L”图像，它的模式将变化为“P”。调色板序列需要包含768项整数，每组三个值表示对应像素的红，绿和蓝。用户可以使用768个byte的字符串代替这个整数序列。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.putpalette([1,2,3])&gt;&gt;&gt; r.mode'P' 21、 Putpixel定义：im.putpixel(xy,colour) 含义：修改指定位置上的像素值。对于单通道图像，变量colour为一个数值；对于多通道图像，变量colour为一个元组。 注意：这个方法执行比较慢。如果是1.1.6版本，像素访问对象（参考load方法）提供了一个更快的方法修改图像。如果用户要生成整幅图像，可以使用更有效的方法产生一个python list，然后使用方法putdata()将它拷贝到图像上去。对于更大的改变，使用方法paste或者ImageDraw模块。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.putpixel((0,0),(1,2,3))&gt;&gt;&gt;im01.getpixel((0,0))(1, 2, 3) 22、 Quantize定义：im.quantize(colors,**options) ⇒ image 含义：（不赞成）使用给定的颜色将“L”或者“RGB”图像转换为“P”图像，返回新的图像。 新的代码中，使用有自适应的调色板的convert方法来代替： out =im.convert(“P”, palette=Image.ADAPTIVE,colors=256) 23、 Resize定义：im.resize(size) ⇒ image im.resize(size, filter) ⇒ image 含义：返回改变尺寸的图像的拷贝。变量size是所要求的尺寸，是一个二元组：（width, height）。 变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 注意：在当前的版本中bilinear和bicubic滤波器不能很好地适应大比例的下采样（例如生成缩略图）。用户需要使用ANTIALIAS，除非速度比质量更重要。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; im= im01.resize((512, 384))&gt;&gt;&gt;im.size(512, 384) 24、 Rotate定义：im.rotate(angle) ⇒ image im.rotate(angle,filter=NEAREST, expand=0) ⇒ image 含义：返回一个按照给定角度顺时钟围绕图像中心旋转后的图像拷贝。 变量filter应该是NEAREST、BILINEAR或者BICUBIC之一。如果省略该变量，或者图像模式为“1”或者“P”，则默认为NEAREST。 变量expand，如果为true，表示输出图像足够大，可以装载旋转后的图像。如果为false或者缺省，则输出图像与输入图像尺寸一样大。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.size(1024, 768)&gt;&gt;&gt;im_30_1 = im01.rotate(30, Image.BICUBIC,1)&gt;&gt;&gt;im_30_1.size(1271, 1178) 25、Save定义：im.save(outfile,options…) im.save(outfile, format, options…) 含义：使用给定的文件名保存图像。如果变量format缺省，如果可能的话，则从文件名称的扩展名判断文件的格式。该方法返回为空。 关键字options为文件编写器提供一些额外的指令。如果编写器不能识别某个选项，它将忽略它。 用户可以使用文件对象代替文件名称。在这种情况下，用户必须指定文件格式。文件对象必须实现了seek()、tell()和write()方法，且其以二进制模式打开。 如果方法save()因为某些原因失败，这个方法将产生一个异常（通常为IOError异常）。如果发生了异常，该方法也有可能已经创建了文件，并向文件写入了一些数据。如果需要的话，用户的应用程序可以删除这个不完整的文件。 例子：1234567891011&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.save("D:\\Code\\Python\\test\\img\\test_rotate_30.jpg") 26、 Seek定义：im.seek(frame) 含义：在给定的文件序列中查找指定的帧。如果查找超越了序列的末尾，则产生一个EOFError异常。当文件序列被打开时，PIL库自动指定到第0帧上。 注意：在当前的版本上，大多数序列格式只允许用户查找下一帧，不能跳跃式查找指定的帧。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.mode'P'&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(2)&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.show()通过上面的code，分别找到了第2帧和第8帧图像。 27、 Show定义：im.show() 含义：显示一张图像。这个方法主要用于调试。 在Unix平台，这个方法将图像保存为临时的PPM文件，并且调用xv功能。 在widows中，它将图像保存为临时的BMP文件，并且使用标准的BMP显示功能显示它。 这个方法返回空。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.show() 28、 Split定义：im.split() ⇒ sequence 含义：返回当前图像各个通道组成的一个元组。例如，分离一个“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝）。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.size(1024, 768) 29、 Tell定义：im.tell() ⇒ integer 含义：返回当前帧所处位置，从0开始计算。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.tell()0&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.tell()8 30、 Thumbnail定义：im.thumbnail(size) im.thumbnail(size, filter) 含义：修改当前图像，使其包含一个自身的缩略图，该缩略图尺寸不大于给定的尺寸。这个方法会计算一个合适的缩略图尺寸，使其符合当前图像的宽高比，调用方法draft()配置文件读取器，最后改变图像的尺寸。 变量filter应该是NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果省略该变量，则默认为NEAREST。 注意：在当前PIL的版本中，滤波器bilinear和bicubic不能很好地适应缩略图产生。用户应该使用ANTIALIAS，图像质量最好。如果处理速度比图像质量更重要，可以选用其他滤波器。 这个方法在原图上进行修改。如果用户不想修改原图，可以使用方法copy()拷贝一个图像。这个方法返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.thumbnail((100,100))应该已经为图像im01创建了不大于100x100的缩略图。 31、 Tobitmap定义：im.tobitmap()⇒ string 含义：返回转换为X11的bitmap图像。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tobitmap() Traceback (mostrecent call last): File "&lt;pyshell#279&gt;", line 1,in &lt;module&gt; str0 = im01.tobitmap() File"C:\Python27\lib\site-packages\PIL\Image.py", line 710, in tobitmap raise ValueError("not a bitmap")ValueError: nota bitmap暂时不知道因为什么原因，需要debug。 32、 Tostring定义：im.tostring() ⇒ string 含义：返回一个使用标准“raw”编码器生成的包含像素数据的字符串。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tostring()Traceback (mostrecent call last): File "&lt;pyshell#281&gt;", line 1,in &lt;module&gt; str0= im01.tostring() File"C:\Python27\lib\site-packages\PIL\Image.py", line 695, in tostring "Please call tobytes() instead.")Exception:tostring() has been removed. Please call tobytes() instead.当前PIL版本已经去除了该方法。 33、 Transform定义1：im.transform(size,method, data) ⇒ image im.transform(size, method, data, filter) ⇒ image 含义1：使用给定的尺寸生成一张新的图像，与原图有相同的模式，使用给定的转换方式将原图数据拷贝到新的图像中。 在当前的PIL版本中，参数method为EXTENT（裁剪出一个矩形区域），AFFINE（仿射变换），QUAD（将正方形转换为矩形），MESH（一个操作映射多个正方形）或者PERSPECTIVE。 变量filter定义了对原始图像中像素的滤波器。在当前的版本中，变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 例子1：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans1 =im01.transform((300,300), Image.EXTENT, (0, 0, 600, 600))&gt;&gt;&gt; trans1.size(300, 300) 定义2：im.transform(size,EXTENT, data) ⇒ image im.transform(size, EXTENT, data, filter) ⇒ image 含义2：从图像中裁剪一个区域。 变量data为指定输入图像中两个坐标点的4元组(x0,y0,x1,y1)。输出图像为这两个坐标点之间像素的采样结果。例如，如果输入图像的(x0,y0)为输出图像的（0，0）点，(x1,y1)则与变量size一样。 这个方法可以用于在当前图像中裁剪，放大，缩小或者镜像一个任意的长方形。它比方法crop()稍慢，但是与resize操作一样快。 定义3：im.transform(size, AFFINE, data) ⇒ image im.transform(size, AFFINE,data, filter) ⇒ image 含义3：对当前的图像进行仿射变换，变换结果体现在给定尺寸的新图像中。 变量data是一个6元组(a,b,c,d,e,f)，包含一个仿射变换矩阵的第一个两行。输出图像中的每一个像素（x，y），新值由输入图像的位置（ax+by+c, dx+ey+f）的像素产生，使用最接近的像素进行近似。 这个方法用于原始图像的缩放、转换、旋转和裁剪。 例子3：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans3 =im01.transform((300,300), Image.AFFINE, (1,2,3,2,1,4))&gt;&gt;&gt; trans3.size(300, 300) 定义4：im.transform(size,QUAD, data) ⇒ image im.transform(size, QUAD, data, filter) ⇒ image 含义4：输入图像的一个四边形（通过四个角定义的区域）映射到给定尺寸的长方形。 变量data是一个8元组(x0,y0,x1,y1,x2,y2,x3,y3)，它包括源四边形的左上，左下，右下和右上四个角。 例子4：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans4 =im01.transform((300,300), Image.QUAD, (0,0,0,500,600,500,600,0))&gt;&gt;&gt; trans4.size(300, 300) 定义5：im.transform(size,MESH, data) ⇒ image im.transform(size, MESH, data, filter) ⇒ image 含义5：与QUAD类似，但是变量data是目标长方形和对应源四边形的list。 定义6：im.transform(size,PERSPECTIVE, data) ⇒ image im.transform(size, PERSPECTIVE, data, filter) ⇒ image 含义6：对当前图像进行透视变换，产生给定尺寸的新图像。 变量data是一个8元组(a,b,c,d,e,f,g,h)，包括一个透视变换的系数。对于输出图像中的每个像素点，新的值来自于输入图像的位置的(a x + b y + c)/(g x + h y + 1), (d x+ e y + f)/(g x + h y + 1)像素，使用最接近的像素进行近似。 这个方法用于原始图像的2D透视。 例子6：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; trans6= im01.transform((300,300), Image.PERSPECTIVE, (1,2,3,2,1,6,1,2))&gt;&gt;&gt;trans6.size(300, 300) 34、 Transpose定义：im.transpose(method)⇒ image 含义：返回当前图像的翻转或者旋转的拷贝。 变量method的取值为：FLIP_LEFT_RIGHT，FLIP_TOP_BOTTOM，ROTATE_90，ROTATE_180，或者ROTATE_270。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im= im01.transpose(Image.FLIP_LEFT_RIGHT)图像im为图像im01的水平方向镜像。 35、Verify定义：im.verify() 含义：尝试判断文件是否损坏，实际上并没有对图像数据进行解析。如果这个方法发现了任何问题，它将产生对应的异常。这个方法只工作于刚打开的图像；如果图像已经被加载，该方法的结果将会是未定义的。如果用户在使用这个方法后需要加载图像，用户需要重新打开图像文件。 注意：这个方法不能捕获所有的错误；要捕获解码错误，用户必须加载整个图像。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.verify()没有任何输出，表示图像im01是没有损坏的。]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫小实例</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>pymatplotlib库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
