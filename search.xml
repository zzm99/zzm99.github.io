<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用PIL库进行gif图的解析或合成]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create1%2F</url>
    <content type="text"></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PIL库里的基本知识概念]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create%2F</url>
    <content type="text"><![CDATA[首先，介绍一下PIL中的基本概念。PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。 1、 通道每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 方法getbands()的使用如下：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.getbands()('R', 'G', 'B')&gt;&gt;&gt;im_bands = im.getbands()&gt;&gt;&gt;len(im_bands)3&gt;&gt;&gt;print im_bands[0]R&gt;&gt;&gt;print im_bands[1]G&gt;&gt;&gt;print im_bands[2]B 2、 模式图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： 1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用如下：12345678&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;md = im.mode&gt;&gt;&gt;print mdRGB 3、 尺寸通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性mode的使用如下：1234567891011&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_size = im.size&gt;&gt;&gt;print im_size[0]800&gt;&gt;&gt;print im_size[1]450 4、 坐标系统PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 5、 调色板调色板模式 (“P”)使用一个颜色调色板为每个像素定义具体的颜色值 6、 信息使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 属性info的使用如下：1234567891011121314&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im_info = im.info&gt;&gt;&gt;im_info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;print im_info['jfif_version'](1, 1)&gt;&gt;&gt;print im_info['jfif']257 7、 滤波器对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为：resize(size, filter=None)=&gt; image12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_resize = im.resize((256,256))&gt;&gt;&gt;im_resize.size(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011&gt;&gt;&gt;im_resize0 = im.resize((256,256), Image.BILINEAR)&gt;&gt;&gt;im_resize0.size(256, 256)&gt;&gt;&gt;im_resize1 = im.resize((256,256), Image.BICUBIC)&gt;&gt;&gt;im_resize1.size(256, 256)&gt;&gt;&gt;im_resize2 = im.resize((256,256), Image.ANTIALIAS)&gt;&gt;&gt;im_resize2.size(256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None)12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200))&gt;&gt;&gt;im.size(200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011121314151617181920212223&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200),Image.BILINEAR)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.BICUBIC)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.ANTIALIAS)&gt;&gt;&gt;im.size(200, 112) 接着，说说PIL中的Image模块Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。 一、Image类的属性1、 Format定义：im.format ⇒ string or None 含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。 例子：12345678910&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.format'JPEG'注：test.jpg是JPEG图像，所以其文件格式为JPEG。&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.format'GIF'注：test.gif为GIF文件，所以其文件格式为GIF。 2、 Mode定义：im.mode ⇒ string 含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P' 3、 Size定义：im.size ⇒ (width, height) 含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt; im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt; im.size(400, 220) 4、 Palette定义：im.palette ⇒ palette or None 含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 例子：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im.palette&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P'&gt;&gt;&gt;im.palette&lt;PIL.ImagePalette.ImagePaletteobject at 0x035E7AD0&gt;&gt;&gt;&gt;pl= im.palettePl为ImagePalette类的实例。 5、 Info定义：im.info ⇒ dictionary 含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.info&#123;'duration':100, 'version': 'GIF89a', 'extension': ('NETSCAPE2.0', 795L), 'background': 0,'loop': 0&#125; 二、Image类的函数1、 New定义：Image.new(mode,size) ⇒ image Image.new(mode, size, color) ⇒ image 含义：使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 例子：123456789101112&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "#FF0000")&gt;&gt;&gt;im.show()图像im为128x128大小的红色图像。&gt;&gt;&gt;im= Image.new("RGB", (128, 128))&gt;&gt;&gt;im.show()图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "red")&gt;&gt;&gt;im.show图像im为128x128大小的红色图像。 2、 Open定义：Image.open(file) ⇒ image Image.open(file, mode) ⇒ image 含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。 用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 例子：123456&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg", "r")&gt;&gt;&gt;im.show() 3、 Blend 定义：Image.blend(image1,image2, alpha) ⇒ image 含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。 例子： from PIL import Image im01 =Image.open(“D:\Code\Python\test\img\test01.jpg”) im02 =Image.open(“D:\Code\Python\test\img\test02.jpg”) im =Image.blend(im01, im02, 0.3) im.show() Test01.jpg和test02.jpg两张图像size都为1024x768，mode为“RGB”。它们按照第一张70%的透明度，第二张30%的透明度，合成为一张。 4、 Composite 定义：Image.composite(image1,image2, mask) ⇒ image 含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。 例子： from PIL import Image im01 =Image.open(“D:\Code\Python\test\img\test01.jpg”) im02 =Image.open(“D:\Code\Python\test\img\test02.jpg”) r,g,b = im01.split() g.mode ‘L’ g.size (1024, 768) im= Image.composite(im01, im02, g) im.show() 5、 Eval 定义：Image.eval(image,function) ⇒ image 含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。 例子： from PIL import Image im01 = Image.open(“D:\Code\Python\test\img\test01.jpg”) deffun(x): return x * 0.5 im_eval = Image.eval(im01, fun) im_eval.show() im01.show() 图像im01如下图： 图像im_eval如下图： 图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。 6、 Frombuffer 定义：Image.frombuffer(mode,size, data) ⇒ image Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image 含义：（New in PIL 1.1.4）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。 注意：版本1.1.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示： im =Image.frombuffer(mode, size, data, “raw”, mode, 0, 1) 函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。 例子： 7、 Fromstring 定义：Image.fromstring(mode,size, data) ⇒ image Image.fromstring(mode, size,data, decoder, parameters) ⇒ image 含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。 函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder. 注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。 例子： 8、 Merge 定义：Image.merge(mode,bands) ⇒ image 含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) 例子： from PIL import Image im01 = Image.open(“D:\Code\Python\test\img\test01.jpg”) im02 = Image.open(“D:\Code\Python\test\img\test02.jpg”) r1,g1,b1 = im01.split() r2,g2,b2 = im02.split() r1.mode ‘L’ r1.size (1024, 768) g1.mode ‘L’ g1.size (1024, 768) r2.mode ‘L’ g2.size (1024, 768) imgs=[r1,g2,b2] len(ImageMode.getmode(“RGB”).bands) 3 len(imgs) 3 im_merge = Image.merge(“RGB”, imgs) im_merge.show() 图像im_merge如下所示：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>pymatplotlib库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
