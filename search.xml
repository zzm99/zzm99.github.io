<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>Python</category>
        <category>pymatplotlib库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
