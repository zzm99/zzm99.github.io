<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用PIL库进行gif图的解析或合成]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create1%2F</url>
    <content type="text"><![CDATA[那个星夜越过千年而我绕过半个地球重新来寻那个你那个亮尽我的眼的你一颗流星划过坠入无边黑暗你等我一千年我找你十万里——《星空》湮夫 跨界艺术家插画师James R. Eads的画作，似乎一下子游离到了另一个世界。在他的笔下，一个个创思化身成一个个闪光的光点，五彩缤纷，随意萦绕，勾勒出一个个美轮美奂的画境，似有阳光的热烈，也有月光的浪漫，更有浩瀚星光似的唯美与空明，让人很容易就沉浸在这美妙的小宇宙中。 受梵高的绘画风格影响，他巧妙地将色彩与富有动感的笔触结合起来，使画面梦幻而富有冲击力。神秘缤纷的色彩、浩瀚如宇宙的笔触，自然与人就这样被James R. Eads用独特的绘画方法结合在一起，启发著人们去思考人与人、人与自然之间的关系。 欣赏作品： 我们尝试利用PIL库将gif图进行解析， 然后再重新合成gif图， 并改变帧的变化速率。 解析gif图代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#-*- coding: UTF-8 -*- import osfrom PIL import Image def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print ("saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile)) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def main(): processImage('1.gif') if __name__ == "__main__": main() 合成gif图代码：12345678910111213141516171819202122#-*- coding: UTF-8 -*- import imageio def create_gif(image_list, gif_name): frames = [] for image_name in image_list: frames.append(imageio.imread(image_name)) # Save them as frames into a gif imageio.mimsave(gif_name, frames, 'GIF', duration = 0.1) return def main(): image_list = ['1-0.png', '1-2.png', '1-4.png', '1-6.png', '1-8.png', '1-10.png'] gif_name = 'created_gif1.gif' create_gif(image_list, gif_name) if __name__ == "__main__": main() 某gif图解析后部分图片如下： gif图合成后：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PIL库里的基本知识概念]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create%2F</url>
    <content type="text"><![CDATA[首先，介绍一下PIL中的基本概念。PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。 1、 通道每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 方法getbands()的使用如下：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.getbands()('R', 'G', 'B')&gt;&gt;&gt;im_bands = im.getbands()&gt;&gt;&gt;len(im_bands)3&gt;&gt;&gt;print im_bands[0]R&gt;&gt;&gt;print im_bands[1]G&gt;&gt;&gt;print im_bands[2]B 2、 模式图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： 1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用如下：12345678&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;md = im.mode&gt;&gt;&gt;print mdRGB 3、 尺寸通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性mode的使用如下：1234567891011&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_size = im.size&gt;&gt;&gt;print im_size[0]800&gt;&gt;&gt;print im_size[1]450 4、 坐标系统PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 5、 调色板调色板模式 (“P”)使用一个颜色调色板为每个像素定义具体的颜色值 6、 信息使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 属性info的使用如下：1234567891011121314&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im_info = im.info&gt;&gt;&gt;im_info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;print im_info['jfif_version'](1, 1)&gt;&gt;&gt;print im_info['jfif']257 7、 滤波器对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为：resize(size, filter=None)=&gt; image12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_resize = im.resize((256,256))&gt;&gt;&gt;im_resize.size(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011&gt;&gt;&gt;im_resize0 = im.resize((256,256), Image.BILINEAR)&gt;&gt;&gt;im_resize0.size(256, 256)&gt;&gt;&gt;im_resize1 = im.resize((256,256), Image.BICUBIC)&gt;&gt;&gt;im_resize1.size(256, 256)&gt;&gt;&gt;im_resize2 = im.resize((256,256), Image.ANTIALIAS)&gt;&gt;&gt;im_resize2.size(256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None)12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200))&gt;&gt;&gt;im.size(200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011121314151617181920212223&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200),Image.BILINEAR)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.BICUBIC)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.ANTIALIAS)&gt;&gt;&gt;im.size(200, 112) 接着，说说PIL中的Image模块Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。 一、Image类的属性1、 Format定义：im.format ⇒ string or None 含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。 例子：12345678910&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.format'JPEG'注：test.jpg是JPEG图像，所以其文件格式为JPEG。&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.format'GIF'注：test.gif为GIF文件，所以其文件格式为GIF。 2、 Mode定义：im.mode ⇒ string 含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P' 3、 Size定义：im.size ⇒ (width, height) 含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt; im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt; im.size(400, 220) 4、 Palette定义：im.palette ⇒ palette or None 含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 例子：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im.palette&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P'&gt;&gt;&gt;im.palette&lt;PIL.ImagePalette.ImagePaletteobject at 0x035E7AD0&gt;&gt;&gt;&gt;pl= im.palettePl为ImagePalette类的实例。 5、 Info定义：im.info ⇒ dictionary 含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.info&#123;'duration':100, 'version': 'GIF89a', 'extension': ('NETSCAPE2.0', 795L), 'background': 0,'loop': 0&#125; 二、Image类的函数1、 New定义：Image.new(mode,size) ⇒ image Image.new(mode, size, color) ⇒ image 含义：使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 例子：123456789101112&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "#FF0000")&gt;&gt;&gt;im.show()图像im为128x128大小的红色图像。&gt;&gt;&gt;im= Image.new("RGB", (128, 128))&gt;&gt;&gt;im.show()图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "red")&gt;&gt;&gt;im.show图像im为128x128大小的红色图像。 2、 Open定义：Image.open(file) ⇒ image Image.open(file, mode) ⇒ image 含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。 用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 例子：123456&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg", "r")&gt;&gt;&gt;im.show() 3、 Blend定义：Image.blend(image1,image2, alpha) ⇒ image 含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;im =Image.blend(im01, im02, 0.3)&gt;&gt;&gt;im.show() Test01.jpg和test02.jpg两张图像size都为1024x768，mode为“RGB”。它们按照第一张70%的透明度，第二张30%的透明度，合成为一张。 4、 Composite定义：Image.composite(image1,image2, mask) ⇒ image 含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;g.mode'L'&gt;&gt;&gt; g.size(1024, 768)&gt;&gt;&gt;im= Image.composite(im01, im02, g)&gt;&gt;&gt;im.show() 5、 Eval定义：Image.eval(image,function) ⇒ image 含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;def fun(x): return x * 0.5&gt;&gt;&gt;im_eval = Image.eval(im01, fun)&gt;&gt;&gt;im_eval.show()&gt;&gt;&gt;im01.show() 图像im01如下图： 图像im_eval如下图： 图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。 6、 Frombuffer定义：Image.frombuffer(mode,size, data) ⇒ image Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image 含义：（New in PIL 1.1.4）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。 注意：版本1.1.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示：123im=Image.frombuffer(mode, size, data, "raw", mode, 0, 1)函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。 7、 Fromstring定义：Image.fromstring(mode,size, data) ⇒ image Image.fromstring(mode, size,data, decoder, parameters) ⇒ image 含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。 函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder. 注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。 8、 Merge定义：Image.merge(mode,bands) ⇒ image 含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) 例子：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 = Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r1,g1,b1 = im01.split()&gt;&gt;&gt;r2,g2,b2 = im02.split()&gt;&gt;&gt;r1.mode'L'&gt;&gt;&gt;r1.size(1024, 768)&gt;&gt;&gt;g1.mode'L'&gt;&gt;&gt;g1.size(1024, 768)&gt;&gt;&gt;r2.mode'L'&gt;&gt;&gt;g2.size(1024, 768)&gt;&gt;&gt;imgs=[r1,g2,b2]&gt;&gt;&gt;len(ImageMode.getmode("RGB").bands)3&gt;&gt;&gt;len(imgs)3&gt;&gt;&gt;im_merge = Image.merge("RGB", imgs)&gt;&gt;&gt;im_merge.show() 三、Image类的方法除非另作说明，Image类的所有方法都将返回一个Image类的新实例，这个实例对应于结果图像。 1、 Convert定义1：im.convert(mode)⇒ image 含义1：将当前图像转换为其他模式，并且返回新的图像。 当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。 当从一个颜色图像转换为黑白图像时，PIL库使用ITU-R601-2 luma转换公式： L = R 299/1000 + G 587/1000 + B * 114/1000 当转换为2位图像（模式“1”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。为了去掉图像抖动现象，可以使用dither选项。 例子1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im_c = im01.convert("L")&gt;&gt;&gt;im_c.mode'L'将“RGB”模式的im01图像，转换为“L”模式的im_c图像。定义2：im.convert(“P”,**options) ⇒ image含义2：这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：Dither=. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。Palette=. 控制调色板的产生。默认是WEB，这是标准的216色的“web palette”。要使用优化的调色板，则赋值为ADAPTIVE。Colors=. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色。例子2： 定义3：im.convert(mode,matrix) ⇒ image含义3：使用转换矩阵将一个“RGB”图像转换为“L”或者“RGB”图像。变量matrix为4或者16元组。例子3：下面的例子将一个RGB图像（根据ITU-R709线性校准，使用D65亮度）转换到CIE XYZ颜色空间：&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;rgb2xyz = ( 0.412453,0.357580, 0.180423, 0, 0.212671,0.715160, 0.072169, 0, 0.019334,0.119193, 0.950227, 0 ) &gt;&gt;&gt;im_c3 = im01.convert("L", rgb2xyz)&gt;&gt;&gt;im_c3.show()&gt;&gt;&gt;im_c3.mode'L' 2、 Copy定义：im.copy() ⇒ image 含义：拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。 例子：123&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_copy = im01.copy() 图像im_copy和im01完全一样。 3、 Crop定义：im.crop(box) ⇒ image 含义：从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。 这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box= [0, 0, 100, 100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im_crop.size(100, 100) 4、 Draft定义：im.draft(mode,size) 含义：配置图像文件加载器，使得返回一个与给定的模式和尺寸尽可能匹配的图像的版本。例如，用户可以使用这个方法，在加载一个彩色JPEG图像时将其转换为灰色图像，或者从一个PCD文件中提取一个128x192的版本。 注意：这个方法会适时地修改图像对象（精确地说，它会重新配置文件的读取器）。如果图像已经被加载，那这个方法就没有作用了。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.draft("L", (100,100))&lt;PIL.JpegImagePlugin.JpegImageFileimage mode=L size=128x96 at 0x3B69230&gt;&gt;&gt;&gt;im01.size(128, 96)&gt;&gt;&gt;im01.mode'L' 5、 Filter定义：im.filter(filter) ⇒ image 含义：返回一个使用给定滤波器处理过的图像的拷贝。可用滤波器需要参考ImageFilter模块。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_filter = im01.filter(ImageFilter.BLUR)&gt;&gt;&gt;im_filter.show() 图像im_filter比im01变得有些模糊了。 6、 Fromstring定义：im.fromstring(data) im.fromstring(data, decoder,parameters) 含义：与函数fromstring()一样，但是这个方法会将data加载到当前的图像中。 7、 Getbands定义：im.getbands()⇒ tuple of strings 含义：返回包括每个通道名称的元组。例如，对于RGB图像将返回（“R”，“G”，“B”）。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbands()('R', 'G', 'B') 8、 Getbbox定义：im.getbbox() ⇒ 4-tuple or None 含义：计算图像非零区域的包围盒。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbbox()(0, 0, 1024,768) 9、 Getcolors定义：im.getcolors() ⇒ a list of(count, color) tuples or None im.getcolors(maxcolors) ⇒ a list of (count, color) tuples or None 含义：（New in 1.1.5）返回一个（count，color）元组的无序list，其中count是对应颜色在图像中出现的次数。 如果变量maxcolors的值被超过，该方法将停止计算并返回空。变量maxcolors默认值为256。为了保证用户可以获取图像中的所有颜色，you can pass in size[0]*size[1]（请确保有足够的内存做这件事）。 例子：12345678910111213141516171819202122232425&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getcolors()&gt;&gt;&gt;im01.getcolors(256)&gt;&gt;&gt;ls= im01.getcolors(255)&gt;&gt;&gt;len(ls) Traceback (mostrecent call last): File "&lt;pyshell#201&gt;", line 1,in &lt;module&gt; len(ls)TypeError:object of type 'NoneType' has no len() 不知道为什么图像im01.getcolors()返回为空，这个后续需要进一步研究。 10、 Getdata定义：im.getdata() ⇒ sequence 含义：以包含像素值的sequence对象形式返回图像的内容。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。 注意：这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用list(im.getdata())，将它转换为普通的sequence。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;seq= im01.getdata()&gt;&gt;&gt;seq0 = list(seq)&gt;&gt;&gt;seq[0](11, 113, 198)&gt;&gt;&gt;seq[2](9, 111, 196)&gt;&gt;&gt;seq0[0](11, 113, 198)&gt;&gt;&gt;seq0[2](9, 111, 196)Sequence对象的每一个元素对应一个像素点的R、G和B三个值。 11、Getextrema定义：im.getextrema() ⇒ 2-tuple 含义：返回一个2元组，包括该图像中的最小和最大值。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getextrema()((0, 255), (0,255), (0, 255))该方法返回了R/G/B三个通道的最小和最大值的2元组。 12、Getpixel定义：im.getpixel(xy) ⇒ value or tuple 含义：返回给定位置的像素值。如果图像为多通道，则返回一个元组。 注意：该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.getpixel((1,1))(10, 112, 197)&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.getpixel((0,0))11 13、Histogram定义1：im.histogram()⇒ list 含义1：返回一个图像的直方图。这个直方图是关于像素数量的list，图像中的每个像素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值）。 二值图像（模式为“1”）当作灰度图像（模式为“L”）处理。 例子1：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;ls= im01.histogram()&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]359&gt;&gt;&gt;ls[256]295&gt;&gt;&gt;ls[767]109953图像im01为RGB图像，所以有768项。 定义2：im.histogram(mask)⇒ list 含义2：返回图像中模板图像非零地方的直方图。模板图像与处理图像的尺寸必须相同，并且要么是二值图像（模式为“1”），要么为灰度图像（模式为“L”）。 例子2：123456789101112131415161718&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;ls= im01.histogram(r)&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]0&gt;&gt;&gt;ls[256]248&gt;&gt;&gt;ls[767]109953 14、Load定义：im.load() 含义：为图像分配内存并从文件中加载它（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。 （New in 1.1.6）在1.1.6及以后的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如： pix = im.load() print pix[x, y] pix[x, y] =value 通过这个对象访问比方法getpixel()和putpixel()快很多。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;pix= im01.load()&gt;&gt;&gt;pix[0,0](11, 113, 198) 15、Offset定义：im.offset(xoffset,yoffset) ⇒ image 含义：（不赞成）返回按照给定位置的偏移对应的图像的拷贝。数据延续到图像的边缘。如果变量yoffset没有赋值，将假设其与变量xoffset一样。 不赞成使用这个方法，在PIL 1.2版本中去掉该方法。新的代码将使用ImageChops模块中的offset()函数。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;img= im01.offset(1,1) Traceback (mostrecent call last): File "&lt;pyshell#38&gt;", line 1,in &lt;module&gt; img = im01.offset(1,1) File"C:\Python27\lib\site-packages\PIL\Image.py", line 1246, in offset "Please call ImageChops.offset()instead.")Exception:offset() has been removed. Please call ImageChops.offset() instead.由此可见，该版本中已经去掉了方法offset()。]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>pymatplotlib库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
