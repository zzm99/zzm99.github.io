<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-221-Maximal Square]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode-221%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.Example: Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Output: 4 To apply DP, we define the state as the maximal size (square = size * size) of the square that can be formed till point (i, j), denoted as dp[i][j]. For the topmost row (i = 0) and the leftmost column (j = 0), we have dp[i][j] = matrix[i][j] - ‘0’, meaning that it can at most form a square of size 1 when the matrix has a ‘1’ in that cell. When i &gt; 0 and j &gt; 0, if matrix[i][j] = ‘0’, then dp[i][j] = 0 since no square will be able to contain the ‘0’ at that cell. If matrix[i][j] = ‘1’, we will have dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1, which means that the square will be limited by its left, upper and upper-left neighbors. dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1: 约束该点最大方形面积的三个因素： 左边延申的距离， 上面延申的距离， 左上延申的距离（对角线） 123456789101112131415161718192021 class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; dp[i][j] = matrix[i][j] - '0'; &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; sz = max(dp[i][j], sz); &#125; &#125; return sz * sz; &#125;&#125;; In the above code, it uses O(mn) space. Actually each time when we update dp[i][j], we only need dp[i-1][j-1], dp[i-1][j] (the previous row) and dp[i][j-1] (the current row). So we may just keep two rows. 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0; vector&lt;int&gt; pre(n, 0), cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); &#125; fill(pre.begin(), pre.end(), 0); swap(pre, cur); &#125; return sz * sz; &#125;&#125;; Furthermore, we may only use just one vector 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) &#123; return 0; &#125; int m = matrix.size(), n = matrix[0].size(), sz = 0, pre; vector&lt;int&gt; cur(n, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int temp = cur[j]; if (!i || !j || matrix[i][j] == '0') &#123; cur[j] = matrix[i][j] - '0'; &#125; else &#123; cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1; &#125; sz = max(cur[j], sz); pre = temp; &#125; &#125; return sz * sz; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top 100 liked questions</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode-236%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the binary tree.Accepted 我们在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，我们可以用递归来实现，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 1）若p和q要么分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。 2）若p和q同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。 3）若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if( root == nullptr or root == p or root == q ) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor( root-&gt;left, p, q ); TreeNode* right = lowestCommonAncestor( root-&gt;right, p, q ); if( left == nullptr ) &#123; return right; &#125; if( right == nullptr ) &#123; return left; &#125; return root; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>top 100 liked questions</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Pytorch库实现动图线性回归]]></title>
    <url>%2F2019%2F05%2F03%2Fpython%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92gif%2F</url>
    <content type="text"><![CDATA[python代码：1234567891011121314151617181920212223242526272829303132333435363738import torchimport torch.nn as nnimport matplotlib.pyplot as pltimport imageiotorch.manual_seed(0)num_samples = 100x_train = torch.linspace(0, 1, num_samples)y_train = 0.1 * x_train + 0.2 + torch.randn(num_samples)*0.03w = torch.randn(1, requires_grad=True)b = torch.randn(1, requires_grad=True)criterion = nn.MSELoss()optimizer = torch.optim.SGD([w,b], lr=0.01)images = []num_epochs = 4000for epoch in range(num_epochs): y_pred = w * x_train + b loss = criterion(y_pred, y_train) optimizer.zero_grad() loss.backward() if epoch % 100 == 99: plt.figure() plt.ylim(torch.min(y_train).item(), torch.max(y_train).item()) plt.scatter(x_train.tolist(), y_train.tolist(), marker='.') plt.plot(x_train.tolist(), y_pred.tolist(), color='r', linewidth=2) plt.title('Epoch [&#123;&#125;/&#123;&#125;], Loss: &#123;:.6f&#125;, \n Weight: &#123;:.6f&#125;, Bias: &#123;:.6f&#125;' .format(epoch+1, num_epochs, loss.item(), w.item(), b.item())) plt.savefig('a.png') plt.close() images.append(imageio.imread('a.png')) optimizer.step() imageio.mimsave('gen.gif', images, duration=0.5) 效果图：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PyTorch库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用PIL库进行gif图的解析或合成]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create1%2F</url>
    <content type="text"><![CDATA[那个星夜越过千年而我绕过半个地球重新来寻那个你那个亮尽我的眼的你一颗流星划过坠入无边黑暗你等我一千年我找你十万里——《星空》湮夫 跨界艺术家插画师James R. Eads的画作，似乎一下子游离到了另一个世界。在他的笔下，一个个创思化身成一个个闪光的光点，五彩缤纷，随意萦绕，勾勒出一个个美轮美奂的画境，似有阳光的热烈，也有月光的浪漫，更有浩瀚星光似的唯美与空明，让人很容易就沉浸在这美妙的小宇宙中。 受梵高的绘画风格影响，他巧妙地将色彩与富有动感的笔触结合起来，使画面梦幻而富有冲击力。神秘缤纷的色彩、浩瀚如宇宙的笔触，自然与人就这样被James R. Eads用独特的绘画方法结合在一起，启发著人们去思考人与人、人与自然之间的关系。 欣赏作品： 我们尝试利用PIL库将gif图进行解析， 然后再重新合成gif图， 并改变帧的变化速率。 解析gif图代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#-*- coding: UTF-8 -*- import osfrom PIL import Image def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print ("saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile)) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def main(): processImage('1.gif') if __name__ == "__main__": main() 合成gif图代码：12345678910111213141516171819202122#-*- coding: UTF-8 -*- import imageio def create_gif(image_list, gif_name): frames = [] for image_name in image_list: frames.append(imageio.imread(image_name)) # Save them as frames into a gif imageio.mimsave(gif_name, frames, 'GIF', duration = 0.1) return def main(): image_list = ['1-0.png', '1-2.png', '1-4.png', '1-6.png', '1-8.png', '1-10.png'] gif_name = 'created_gif1.gif' create_gif(image_list, gif_name) if __name__ == "__main__": main() 某gif图解析后部分图片如下： gif图合成后：]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PIL库里的基本知识概念]]></title>
    <url>%2F2019%2F04%2F29%2Fgif-create%2F</url>
    <content type="text"><![CDATA[首先，介绍一下PIL中的基本概念。PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。 1、 通道每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 方法getbands()的使用如下：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.getbands()('R', 'G', 'B')&gt;&gt;&gt;im_bands = im.getbands()&gt;&gt;&gt;len(im_bands)3&gt;&gt;&gt;print im_bands[0]R&gt;&gt;&gt;print im_bands[1]G&gt;&gt;&gt;print im_bands[2]B 2、 模式图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： 1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用如下：12345678&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;md = im.mode&gt;&gt;&gt;print mdRGB 3、 尺寸通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性mode的使用如下：1234567891011&gt;&gt;&gt;from PIL importImage&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_size = im.size&gt;&gt;&gt;print im_size[0]800&gt;&gt;&gt;print im_size[1]450 4、 坐标系统PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 5、 调色板调色板模式 (“P”)使用一个颜色调色板为每个像素定义具体的颜色值 6、 信息使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 属性info的使用如下：1234567891011121314&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im =Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im_info = im.info&gt;&gt;&gt;im_info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;print im_info['jfif_version'](1, 1)&gt;&gt;&gt;print im_info['jfif']257 7、 滤波器对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为：resize(size, filter=None)=&gt; image12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im_resize = im.resize((256,256))&gt;&gt;&gt;im_resize.size(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011&gt;&gt;&gt;im_resize0 = im.resize((256,256), Image.BILINEAR)&gt;&gt;&gt;im_resize0.size(256, 256)&gt;&gt;&gt;im_resize1 = im.resize((256,256), Image.BICUBIC)&gt;&gt;&gt;im_resize1.size(256, 256)&gt;&gt;&gt;im_resize2 = im.resize((256,256), Image.ANTIALIAS)&gt;&gt;&gt;im_resize2.size(256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None)12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200))&gt;&gt;&gt;im.size(200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：1234567891011121314151617181920212223&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200),Image.BILINEAR)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.BICUBIC)&gt;&gt;&gt;im.size(200, 112)&gt;&gt;&gt;im= Image.open('D:\\Code\\Python\\test\\img\\1.jpg')&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt;im.thumbnail((200,200), Image.ANTIALIAS)&gt;&gt;&gt;im.size(200, 112) 接着，说说PIL中的Image模块Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。 一、Image类的属性1、 Format定义：im.format ⇒ string or None 含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。 例子：12345678910&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.format'JPEG'注：test.jpg是JPEG图像，所以其文件格式为JPEG。&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.format'GIF'注：test.gif为GIF文件，所以其文件格式为GIF。 2、 Mode定义：im.mode ⇒ string 含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P' 3、 Size定义：im.size ⇒ (width, height) 含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.size(800, 450)&gt;&gt;&gt; im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt; im.size(400, 220) 4、 Palette定义：im.palette ⇒ palette or None 含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 例子：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.mode'RGB'&gt;&gt;&gt;im.palette&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.mode'P'&gt;&gt;&gt;im.palette&lt;PIL.ImagePalette.ImagePaletteobject at 0x035E7AD0&gt;&gt;&gt;&gt;pl= im.palettePl为ImagePalette类的实例。 5、 Info定义：im.info ⇒ dictionary 含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 例子：12345678&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.info&#123;'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)&#125;&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im.info&#123;'duration':100, 'version': 'GIF89a', 'extension': ('NETSCAPE2.0', 795L), 'background': 0,'loop': 0&#125; 二、Image类的函数1、 New定义：Image.new(mode,size) ⇒ image Image.new(mode, size, color) ⇒ image 含义：使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 例子：123456789101112&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "#FF0000")&gt;&gt;&gt;im.show()图像im为128x128大小的红色图像。&gt;&gt;&gt;im= Image.new("RGB", (128, 128))&gt;&gt;&gt;im.show()图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。&gt;&gt;&gt;im= Image.new("RGB", (128, 128), "red")&gt;&gt;&gt;im.show图像im为128x128大小的红色图像。 2、 Open定义：Image.open(file) ⇒ image Image.open(file, mode) ⇒ image 含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。 用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 例子：123456&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im= Image.open("D:\\Code\\Python\\test\\img\\test.jpg", "r")&gt;&gt;&gt;im.show() 3、 Blend定义：Image.blend(image1,image2, alpha) ⇒ image 含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;im =Image.blend(im01, im02, 0.3)&gt;&gt;&gt;im.show() Test01.jpg和test02.jpg两张图像size都为1024x768，mode为“RGB”。它们按照第一张70%的透明度，第二张30%的透明度，合成为一张。 4、 Composite定义：Image.composite(image1,image2, mask) ⇒ image 含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 =Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;g.mode'L'&gt;&gt;&gt; g.size(1024, 768)&gt;&gt;&gt;im= Image.composite(im01, im02, g)&gt;&gt;&gt;im.show() 5、 Eval定义：Image.eval(image,function) ⇒ image 含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;def fun(x): return x * 0.5&gt;&gt;&gt;im_eval = Image.eval(im01, fun)&gt;&gt;&gt;im_eval.show()&gt;&gt;&gt;im01.show() 图像im01如下图： 图像im_eval如下图： 图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。 6、 Frombuffer定义：Image.frombuffer(mode,size, data) ⇒ image Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image 含义：（New in PIL 1.1.4）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。 注意：版本1.1.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示：123im=Image.frombuffer(mode, size, data, "raw", mode, 0, 1)函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。 7、 Fromstring定义：Image.fromstring(mode,size, data) ⇒ image Image.fromstring(mode, size,data, decoder, parameters) ⇒ image 含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。 函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder. 注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。 8、 Merge定义：Image.merge(mode,bands) ⇒ image 含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) 例子：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im02 = Image.open("D:\\Code\\Python\\test\\img\\test02.jpg")&gt;&gt;&gt;r1,g1,b1 = im01.split()&gt;&gt;&gt;r2,g2,b2 = im02.split()&gt;&gt;&gt;r1.mode'L'&gt;&gt;&gt;r1.size(1024, 768)&gt;&gt;&gt;g1.mode'L'&gt;&gt;&gt;g1.size(1024, 768)&gt;&gt;&gt;r2.mode'L'&gt;&gt;&gt;g2.size(1024, 768)&gt;&gt;&gt;imgs=[r1,g2,b2]&gt;&gt;&gt;len(ImageMode.getmode("RGB").bands)3&gt;&gt;&gt;len(imgs)3&gt;&gt;&gt;im_merge = Image.merge("RGB", imgs)&gt;&gt;&gt;im_merge.show() 三、Image类的方法除非另作说明，Image类的所有方法都将返回一个Image类的新实例，这个实例对应于结果图像。 1、 Convert定义1：im.convert(mode)⇒ image 含义1：将当前图像转换为其他模式，并且返回新的图像。 当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。 当从一个颜色图像转换为黑白图像时，PIL库使用ITU-R601-2 luma转换公式： L = R 299/1000 + G 587/1000 + B * 114/1000 当转换为2位图像（模式“1”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。为了去掉图像抖动现象，可以使用dither选项。 例子1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im_c = im01.convert("L")&gt;&gt;&gt;im_c.mode'L'将“RGB”模式的im01图像，转换为“L”模式的im_c图像。定义2：im.convert(“P”,**options) ⇒ image含义2：这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：Dither=. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。Palette=. 控制调色板的产生。默认是WEB，这是标准的216色的“web palette”。要使用优化的调色板，则赋值为ADAPTIVE。Colors=. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色。例子2： 定义3：im.convert(mode,matrix) ⇒ image含义3：使用转换矩阵将一个“RGB”图像转换为“L”或者“RGB”图像。变量matrix为4或者16元组。例子3：下面的例子将一个RGB图像（根据ITU-R709线性校准，使用D65亮度）转换到CIE XYZ颜色空间：&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;rgb2xyz = ( 0.412453,0.357580, 0.180423, 0, 0.212671,0.715160, 0.072169, 0, 0.019334,0.119193, 0.950227, 0 ) &gt;&gt;&gt;im_c3 = im01.convert("L", rgb2xyz)&gt;&gt;&gt;im_c3.show()&gt;&gt;&gt;im_c3.mode'L' 2、 Copy定义：im.copy() ⇒ image 含义：拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。 例子：123&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_copy = im01.copy() 图像im_copy和im01完全一样。 3、 Crop定义：im.crop(box) ⇒ image 含义：从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。 这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box= [0, 0, 100, 100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im_crop.size(100, 100) 4、 Draft定义：im.draft(mode,size) 含义：配置图像文件加载器，使得返回一个与给定的模式和尺寸尽可能匹配的图像的版本。例如，用户可以使用这个方法，在加载一个彩色JPEG图像时将其转换为灰色图像，或者从一个PCD文件中提取一个128x192的版本。 注意：这个方法会适时地修改图像对象（精确地说，它会重新配置文件的读取器）。如果图像已经被加载，那这个方法就没有作用了。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.draft("L", (100,100))&lt;PIL.JpegImagePlugin.JpegImageFileimage mode=L size=128x96 at 0x3B69230&gt;&gt;&gt;&gt;im01.size(128, 96)&gt;&gt;&gt;im01.mode'L' 5、 Filter定义：im.filter(filter) ⇒ image 含义：返回一个使用给定滤波器处理过的图像的拷贝。可用滤波器需要参考ImageFilter模块。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_filter = im01.filter(ImageFilter.BLUR)&gt;&gt;&gt;im_filter.show() 图像im_filter比im01变得有些模糊了。 6、 Fromstring定义：im.fromstring(data) im.fromstring(data, decoder,parameters) 含义：与函数fromstring()一样，但是这个方法会将data加载到当前的图像中。 7、 Getbands定义：im.getbands()⇒ tuple of strings 含义：返回包括每个通道名称的元组。例如，对于RGB图像将返回（“R”，“G”，“B”）。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbands()('R', 'G', 'B') 8、 Getbbox定义：im.getbbox() ⇒ 4-tuple or None 含义：计算图像非零区域的包围盒。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getbbox()(0, 0, 1024,768) 9、 Getcolors定义：im.getcolors() ⇒ a list of(count, color) tuples or None im.getcolors(maxcolors) ⇒ a list of (count, color) tuples or None 含义：（New in 1.1.5）返回一个（count，color）元组的无序list，其中count是对应颜色在图像中出现的次数。 如果变量maxcolors的值被超过，该方法将停止计算并返回空。变量maxcolors默认值为256。为了保证用户可以获取图像中的所有颜色，you can pass in size[0]*size[1]（请确保有足够的内存做这件事）。 例子：12345678910111213141516171819202122232425&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getcolors()&gt;&gt;&gt;im01.getcolors(256)&gt;&gt;&gt;ls= im01.getcolors(255)&gt;&gt;&gt;len(ls) Traceback (mostrecent call last): File "&lt;pyshell#201&gt;", line 1,in &lt;module&gt; len(ls)TypeError:object of type 'NoneType' has no len() 不知道为什么图像im01.getcolors()返回为空，这个后续需要进一步研究。 10、 Getdata定义：im.getdata() ⇒ sequence 含义：以包含像素值的sequence对象形式返回图像的内容。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。 注意：这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用list(im.getdata())，将它转换为普通的sequence。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;seq= im01.getdata()&gt;&gt;&gt;seq0 = list(seq)&gt;&gt;&gt;seq[0](11, 113, 198)&gt;&gt;&gt;seq[2](9, 111, 196)&gt;&gt;&gt;seq0[0](11, 113, 198)&gt;&gt;&gt;seq0[2](9, 111, 196)Sequence对象的每一个元素对应一个像素点的R、G和B三个值。 11、Getextrema定义：im.getextrema() ⇒ 2-tuple 含义：返回一个2元组，包括该图像中的最小和最大值。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getextrema()((0, 255), (0,255), (0, 255))该方法返回了R/G/B三个通道的最小和最大值的2元组。 12、Getpixel定义：im.getpixel(xy) ⇒ value or tuple 含义：返回给定位置的像素值。如果图像为多通道，则返回一个元组。 注意：该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.getpixel((1,1))(10, 112, 197)&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.getpixel((0,0))11 13、Histogram定义1：im.histogram()⇒ list 含义1：返回一个图像的直方图。这个直方图是关于像素数量的list，图像中的每个像素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值）。 二值图像（模式为“1”）当作灰度图像（模式为“L”）处理。 例子1：12345678910111213141516&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;ls= im01.histogram()&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]359&gt;&gt;&gt;ls[256]295&gt;&gt;&gt;ls[767]109953图像im01为RGB图像，所以有768项。 定义2：im.histogram(mask)⇒ list 含义2：返回图像中模板图像非零地方的直方图。模板图像与处理图像的尺寸必须相同，并且要么是二值图像（模式为“1”），要么为灰度图像（模式为“L”）。 例子2：123456789101112131415161718&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;ls= im01.histogram(r)&gt;&gt;&gt;len(ls)768&gt;&gt;&gt;ls[0]0&gt;&gt;&gt;ls[256]248&gt;&gt;&gt;ls[767]109953 14、Load定义：im.load() 含义：为图像分配内存并从文件中加载它（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。 （New in 1.1.6）在1.1.6及以后的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如： pix = im.load() print pix[x, y] pix[x, y] =value 通过这个对象访问比方法getpixel()和putpixel()快很多。 例子：123456789&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;pix= im01.load()&gt;&gt;&gt;pix[0,0](11, 113, 198) 15、Offset定义：im.offset(xoffset,yoffset) ⇒ image 含义：（不赞成）返回按照给定位置的偏移对应的图像的拷贝。数据延续到图像的边缘。如果变量yoffset没有赋值，将假设其与变量xoffset一样。 不赞成使用这个方法，在PIL 1.2版本中去掉该方法。新的代码将使用ImageChops模块中的offset()函数。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;img= im01.offset(1,1) Traceback (mostrecent call last): File "&lt;pyshell#38&gt;", line 1,in &lt;module&gt; img = im01.offset(1,1) File"C:\Python27\lib\site-packages\PIL\Image.py", line 1246, in offset "Please call ImageChops.offset()instead.")Exception:offset() has been removed. Please call ImageChops.offset() instead.由此可见，该版本中已经去掉了方法offset()。 16、 Paste定义1：im.paste(image,box) 含义1：将一张图粘贴到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。 如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。 例子1：1234567891011121314151617181920212223&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box=[0,0,100,100]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;im_crop.size(100, 100)&gt;&gt;&gt;im_crop.mode'RGB'&gt;&gt;&gt;im01.paste(im_crop, (200,200))&gt;&gt;&gt;im01.paste(im_crop, (500,500,600,600))&gt;&gt;&gt;im01.show()我们先从图像im01中裁剪出一个100x100的图像，它的模式与im01一样都是“RGB”。然后通过2元组和4元组的方式，将裁剪出来的图像粘贴到图像im01上。在图像im01的（200，200）和（500，500）两个位置分别出现了裁剪出来的100x100的图像。其结果如下图所示： 定义2：im.paste(colour,box) 含义2：它与定义1一样，但是它使用同一种颜色填充变量box对应的区域。对于单通道图像，变量colour为单个颜色值；对于多通道，则为一个元组。 例子2：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01= Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;im01.paste((0,256,0),(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的绿色方块。 &gt;&gt;&gt;im01.paste(255,(0,0,100,100))图像im01的（0，0）位置将出现一个100x100的红色方块。对于多通道的图像，如果变量colour只给定一个数值，将只会应用于图像的第一个通道。如果是“RGB”模式的图像，将应用于红色通道。 定义3：im.paste(image,box, mask) 含义3：与定义1一样，但是它使用变量mask对应的模板图像来填充所对应的区域。可以使用模式为“1”、“L”或者“RGBA”的图像作为模板图像。模板图像的尺寸必须与变量image对应的图像尺寸一致。如果变量mask对应图像的值为255，则模板图像的值直接被拷贝过来；如果变量mask对应图像的值为0，则保持当前图像的原始值。变量mask对应图像的其他值，将对两张图像的值进行透明融合。 注意：如果变量image对应的为“RGBA”图像，即粘贴的图像模式为“RGBA”，则alpha通道被忽略。用户可以使用同样的图像作为原图像和模板图像。 例子3：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;box =[500,500,600,600]&gt;&gt;&gt;im_crop =im01.crop(box)&gt;&gt;&gt;r,g,b =im_crop.split()&gt;&gt;&gt;im01.paste(im_crop, (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个半透明的100x100的方块。 定义4：im.paste(colour,box, mask) 含义4：与定义3一样，只是使用变量colour对应的单色来填充区域。 例子4：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg") &gt;&gt;&gt;box= [500,500,600,600]&gt;&gt;&gt;im_crop = im01.crop(box)&gt;&gt;&gt;r,g,b = im_crop.split()&gt;&gt;&gt;im01.paste((0,256,0), (0,0,100,100), r)&gt;&gt;&gt;im01.show()在图像im01的（0，0）位置将出现一个100x100的绿色方块。 17、 Point定义1：im.point(table)⇒ image im.point(function) ⇒ image 含义1：返回给定查找表对应的图像像素值的拷贝。变量table为图像的每个通道设置256个值。如果使用变量function，其对应函数应该有一个参数。这个函数将对每个像素值使用一次，结果表格将应用于图像的所有通道。 如果图像的模式为“I（整数）”或者“F（浮点）”，用户必须使用function方式，function必须按照下面的格式： argument * scale+ offset 例如： out = im.point(lambda i: i * 1.2 + 10) 用户可以省略变量scale和offset。 例子1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im_point_fun = im01.point(lambda i:i*1.2+10)&gt;&gt;&gt;im_point_fun.show()图像im_point_fun比原图im01亮度增加了很多；因为lambda表达式中对原图的每个像素点的值都做了增加操作。Lambda表达式是python中可以替代简单函数的一种方式，它只能封装有限的逻辑，但是对于某些情况，使用起来还是很方便的。定义lambda函数的形式如下：labmda参数：表达式lambda函数默认返回表达式的值。你也可以将其赋值给一个变量。lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。Lambda表达式的例子：&gt;&gt;&gt;range(10)[0, 1, 2, 3, 4,5, 6, 7, 8, 9]如果我们要对这10个数字，逐个做加一操作，可以使用如下表达式：&gt;&gt;&gt;map(lambda x:x+1, [y for y in range(10)])[1, 2, 3, 4, 5,6, 7, 8, 9, 10]函数map()是python的内置函数，其格式如下：map( func,seq1[, seq2...]Python函数式编程中的map()函数是将func作用于seq中的每一个元素，并用一个列表给出返回值。如果func为None，作用同zip()。当seq只有一个时，将func函数作用于这个seq的每个元素上，得到一个新的seq。例如：&gt;&gt;&gt;map(lambda x:x+10, range(10))[10, 11, 12, 13,14, 15, 16, 17, 18, 19]当seq多于一个时，map可以并行地对每个seq执行。每个seq的同一位置的元素在执行过一个多元的func函数之后，得到一个返回值，这些返回值放在一个结果列表中。需要注意的是，不同长度的多个seq是无法执行map函数的，会出现类型错误。例如：&gt;&gt;&gt;map(lambda x,y:x+y, [1,2,3],[4,5,6])[5, 7, 9]func是None的情况，它的目的是将多个列表相同位置的元素归并到一个元组，在现在已经有了专用的函数zip()了。例如：&gt;&gt;&gt;map(None, [1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip([1,2,3],[4,5,6])[(1, 4), (2, 5),(3, 6)]zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。例如：&gt;&gt;&gt; a =[1,2,3]&gt;&gt;&gt; b =[2,3,4]&gt;&gt;&gt; b =[4,5,6]&gt;&gt;&gt; c =[4,5,6,7,8]&gt;&gt;&gt;zipped = zip(a,b)&gt;&gt;&gt;zipped[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(a,c)[(1, 4), (2, 5),(3, 6)]&gt;&gt;&gt;zip(*zipped)[(1, 2, 3), (4,5, 6)]定义2：im.point(table,mode) ⇒ imageim.point(function, mode) ⇒ image 含义2：与定义1一样，但是它会为输出图像指定一个新的模式。这个方法可以一步将模式为“L”和“P”的图像转换为模式为“1”的图像。 （New in 1.1.5）这个方法也可以将“L”图像转换为“I”和“F”模式，或者将16 位的“I”模式图像转换为“L”模式，此时必须使用65536项的查找表。 例子2：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt; im= r.point(lambda x:x*1.3+5, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))19图像im为全白图；&gt;&gt;&gt; im= r.point(lambda x:1, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))1图像im为全白图；&gt;&gt;&gt;im= r.point(lambda x:x*0, "1")&gt;&gt;&gt;im.show()&gt;&gt;&gt;im.getpixel((0,0))0图像im为全黑图； 18、 Putalpha定义：im.putalpha(band) 含义：将给定的通道拷贝到图像的alpha层。此处的图像模式必须为“RGBA”，变量band必须为“L”或者“1”。 （New in PIL 1.1.5）方法putalpha()也可以用于其他模式；图像原地转换为有alpha通道的模式（通常转换为“LA”或者“RGBA”）。变量band要么为图像，要么为颜色值（一个整数）。 例子：1234567891011121314151617&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.putalpha(100)&gt;&gt;&gt;im01.mode'RGBA'&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198,100) 19、 Putdata定义：im.putdata(data) im.putdata(data, scale, offset) 含义：从sequence对象中拷贝数据到当前图像，从图像的左上角（0，0）位置开始。变量scale和offset用来调整sequence中的值： pixel = value *scale + offset 如果变量scale忽略，则默认为1.0。如果变量offset忽略，则默认为0.0。 例子：123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; r,g,b =im01.split()&gt;&gt;&gt;r.getpixel((0,0))11&gt;&gt;&gt;r.getpixel((1,0))10&gt;&gt;&gt;r.getpixel((2,0))9&gt;&gt;&gt;r.getpixel((3,0))6&gt;&gt;&gt;r.putdata([1,2,3,4])&gt;&gt;&gt;r.getpixel((0,0))1&gt;&gt;&gt;r.getpixel((1,0))2&gt;&gt;&gt;r.getpixel((2,0))3&gt;&gt;&gt;r.getpixel((3,0))4 20、 Putpalette定义：im.putpalette(sequence) 含义：为“P”或者“L”图像增加一个调色板。对于“L”图像，它的模式将变化为“P”。调色板序列需要包含768项整数，每组三个值表示对应像素的红，绿和蓝。用户可以使用768个byte的字符串代替这个整数序列。 例子：123456789101112131415&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.putpalette([1,2,3])&gt;&gt;&gt; r.mode'P' 21、 Putpixel定义：im.putpixel(xy,colour) 含义：修改指定位置上的像素值。对于单通道图像，变量colour为一个数值；对于多通道图像，变量colour为一个元组。 注意：这个方法执行比较慢。如果是1.1.6版本，像素访问对象（参考load方法）提供了一个更快的方法修改图像。如果用户要生成整幅图像，可以使用更有效的方法产生一个python list，然后使用方法putdata()将它拷贝到图像上去。对于更大的改变，使用方法paste或者ImageDraw模块。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.getpixel((0,0))(11, 113, 198)&gt;&gt;&gt;im01.putpixel((0,0),(1,2,3))&gt;&gt;&gt;im01.getpixel((0,0))(1, 2, 3) 22、 Quantize定义：im.quantize(colors,**options) ⇒ image 含义：（不赞成）使用给定的颜色将“L”或者“RGB”图像转换为“P”图像，返回新的图像。 新的代码中，使用有自适应的调色板的convert方法来代替： out =im.convert(“P”, palette=Image.ADAPTIVE,colors=256) 23、 Resize定义：im.resize(size) ⇒ image im.resize(size, filter) ⇒ image 含义：返回改变尺寸的图像的拷贝。变量size是所要求的尺寸，是一个二元组：（width, height）。 变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 注意：在当前的版本中bilinear和bicubic滤波器不能很好地适应大比例的下采样（例如生成缩略图）。用户需要使用ANTIALIAS，除非速度比质量更重要。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; im= im01.resize((512, 384))&gt;&gt;&gt;im.size(512, 384) 24、 Rotate定义：im.rotate(angle) ⇒ image im.rotate(angle,filter=NEAREST, expand=0) ⇒ image 含义：返回一个按照给定角度顺时钟围绕图像中心旋转后的图像拷贝。 变量filter应该是NEAREST、BILINEAR或者BICUBIC之一。如果省略该变量，或者图像模式为“1”或者“P”，则默认为NEAREST。 变量expand，如果为true，表示输出图像足够大，可以装载旋转后的图像。如果为false或者缺省，则输出图像与输入图像尺寸一样大。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.size(1024, 768)&gt;&gt;&gt;im_30_1 = im01.rotate(30, Image.BICUBIC,1)&gt;&gt;&gt;im_30_1.size(1271, 1178) 25、Save定义：im.save(outfile,options…) im.save(outfile, format, options…) 含义：使用给定的文件名保存图像。如果变量format缺省，如果可能的话，则从文件名称的扩展名判断文件的格式。该方法返回为空。 关键字options为文件编写器提供一些额外的指令。如果编写器不能识别某个选项，它将忽略它。 用户可以使用文件对象代替文件名称。在这种情况下，用户必须指定文件格式。文件对象必须实现了seek()、tell()和write()方法，且其以二进制模式打开。 如果方法save()因为某些原因失败，这个方法将产生一个异常（通常为IOError异常）。如果发生了异常，该方法也有可能已经创建了文件，并向文件写入了一些数据。如果需要的话，用户的应用程序可以删除这个不完整的文件。 例子：1234567891011&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt;im_30 = im01.rotate(30)&gt;&gt;&gt;im_30.save("D:\\Code\\Python\\test\\img\\test_rotate_30.jpg") 26、 Seek定义：im.seek(frame) 含义：在给定的文件序列中查找指定的帧。如果查找超越了序列的末尾，则产生一个EOFError异常。当文件序列被打开时，PIL库自动指定到第0帧上。 注意：在当前的版本上，大多数序列格式只允许用户查找下一帧，不能跳跃式查找指定的帧。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.mode'P'&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(2)&gt;&gt;&gt;im_gif.show()&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.show()通过上面的code，分别找到了第2帧和第8帧图像。 27、 Show定义：im.show() 含义：显示一张图像。这个方法主要用于调试。 在Unix平台，这个方法将图像保存为临时的PPM文件，并且调用xv功能。 在widows中，它将图像保存为临时的BMP文件，并且使用标准的BMP显示功能显示它。 这个方法返回空。 例子：12345&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.show() 28、 Split定义：im.split() ⇒ sequence 含义：返回当前图像各个通道组成的一个元组。例如，分离一个“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝）。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;r,g,b = im01.split()&gt;&gt;&gt;r.mode'L'&gt;&gt;&gt;r.size(1024, 768)&gt;&gt;&gt;im01.mode'RGB'&gt;&gt;&gt;im01.size(1024, 768) 29、 Tell定义：im.tell() ⇒ integer 含义：返回当前帧所处位置，从0开始计算。 例子：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im_gif = Image.open("D:\\Code\\Python\\test\\img\\test.gif")&gt;&gt;&gt;im_gif.tell()0&gt;&gt;&gt;im_gif.seek(8)&gt;&gt;&gt;im_gif.tell()8 30、 Thumbnail定义：im.thumbnail(size) im.thumbnail(size, filter) 含义：修改当前图像，使其包含一个自身的缩略图，该缩略图尺寸不大于给定的尺寸。这个方法会计算一个合适的缩略图尺寸，使其符合当前图像的宽高比，调用方法draft()配置文件读取器，最后改变图像的尺寸。 变量filter应该是NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果省略该变量，则默认为NEAREST。 注意：在当前PIL的版本中，滤波器bilinear和bicubic不能很好地适应缩略图产生。用户应该使用ANTIALIAS，图像质量最好。如果处理速度比图像质量更重要，可以选用其他滤波器。 这个方法在原图上进行修改。如果用户不想修改原图，可以使用方法copy()拷贝一个图像。这个方法返回空。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.thumbnail((100,100))应该已经为图像im01创建了不大于100x100的缩略图。 31、 Tobitmap定义：im.tobitmap()⇒ string 含义：返回转换为X11的bitmap图像。 例子：123456789101112131415161718192021&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tobitmap() Traceback (mostrecent call last): File "&lt;pyshell#279&gt;", line 1,in &lt;module&gt; str0 = im01.tobitmap() File"C:\Python27\lib\site-packages\PIL\Image.py", line 710, in tobitmap raise ValueError("not a bitmap")ValueError: nota bitmap暂时不知道因为什么原因，需要debug。 32、 Tostring定义：im.tostring() ⇒ string 含义：返回一个使用标准“raw”编码器生成的包含像素数据的字符串。 例子：12345678910111213141516171819&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;str0 = im01.tostring()Traceback (mostrecent call last): File "&lt;pyshell#281&gt;", line 1,in &lt;module&gt; str0= im01.tostring() File"C:\Python27\lib\site-packages\PIL\Image.py", line 695, in tostring "Please call tobytes() instead.")Exception:tostring() has been removed. Please call tobytes() instead.当前PIL版本已经去除了该方法。 33、 Transform定义1：im.transform(size,method, data) ⇒ image im.transform(size, method, data, filter) ⇒ image 含义1：使用给定的尺寸生成一张新的图像，与原图有相同的模式，使用给定的转换方式将原图数据拷贝到新的图像中。 在当前的PIL版本中，参数method为EXTENT（裁剪出一个矩形区域），AFFINE（仿射变换），QUAD（将正方形转换为矩形），MESH（一个操作映射多个正方形）或者PERSPECTIVE。 变量filter定义了对原始图像中像素的滤波器。在当前的版本中，变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。 例子1：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans1 =im01.transform((300,300), Image.EXTENT, (0, 0, 600, 600))&gt;&gt;&gt; trans1.size(300, 300) 定义2：im.transform(size,EXTENT, data) ⇒ image im.transform(size, EXTENT, data, filter) ⇒ image 含义2：从图像中裁剪一个区域。 变量data为指定输入图像中两个坐标点的4元组(x0,y0,x1,y1)。输出图像为这两个坐标点之间像素的采样结果。例如，如果输入图像的(x0,y0)为输出图像的（0，0）点，(x1,y1)则与变量size一样。 这个方法可以用于在当前图像中裁剪，放大，缩小或者镜像一个任意的长方形。它比方法crop()稍慢，但是与resize操作一样快。 定义3：im.transform(size, AFFINE, data) ⇒ image im.transform(size, AFFINE,data, filter) ⇒ image 含义3：对当前的图像进行仿射变换，变换结果体现在给定尺寸的新图像中。 变量data是一个6元组(a,b,c,d,e,f)，包含一个仿射变换矩阵的第一个两行。输出图像中的每一个像素（x，y），新值由输入图像的位置（ax+by+c, dx+ey+f）的像素产生，使用最接近的像素进行近似。 这个方法用于原始图像的缩放、转换、旋转和裁剪。 例子3：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans3 =im01.transform((300,300), Image.AFFINE, (1,2,3,2,1,4))&gt;&gt;&gt; trans3.size(300, 300) 定义4：im.transform(size,QUAD, data) ⇒ image im.transform(size, QUAD, data, filter) ⇒ image 含义4：输入图像的一个四边形（通过四个角定义的区域）映射到给定尺寸的长方形。 变量data是一个8元组(x0,y0,x1,y1,x2,y2,x3,y3)，它包括源四边形的左上，左下，右下和右上四个角。 例子4：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im01.size(1024, 768)&gt;&gt;&gt; trans4 =im01.transform((300,300), Image.QUAD, (0,0,0,500,600,500,600,0))&gt;&gt;&gt; trans4.size(300, 300) 定义5：im.transform(size,MESH, data) ⇒ image im.transform(size, MESH, data, filter) ⇒ image 含义5：与QUAD类似，但是变量data是目标长方形和对应源四边形的list。 定义6：im.transform(size,PERSPECTIVE, data) ⇒ image im.transform(size, PERSPECTIVE, data, filter) ⇒ image 含义6：对当前图像进行透视变换，产生给定尺寸的新图像。 变量data是一个8元组(a,b,c,d,e,f,g,h)，包括一个透视变换的系数。对于输出图像中的每个像素点，新的值来自于输入图像的位置的(a x + b y + c)/(g x + h y + 1), (d x+ e y + f)/(g x + h y + 1)像素，使用最接近的像素进行近似。 这个方法用于原始图像的2D透视。 例子6：12345678910111213&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt; im01 =Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.size(1024, 768)&gt;&gt;&gt; trans6= im01.transform((300,300), Image.PERSPECTIVE, (1,2,3,2,1,6,1,2))&gt;&gt;&gt;trans6.size(300, 300) 34、 Transpose定义：im.transpose(method)⇒ image 含义：返回当前图像的翻转或者旋转的拷贝。 变量method的取值为：FLIP_LEFT_RIGHT，FLIP_TOP_BOTTOM，ROTATE_90，ROTATE_180，或者ROTATE_270。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt; im= im01.transpose(Image.FLIP_LEFT_RIGHT)图像im为图像im01的水平方向镜像。 35、Verify定义：im.verify() 含义：尝试判断文件是否损坏，实际上并没有对图像数据进行解析。如果这个方法发现了任何问题，它将产生对应的异常。这个方法只工作于刚打开的图像；如果图像已经被加载，该方法的结果将会是未定义的。如果用户在使用这个方法后需要加载图像，用户需要重新打开图像文件。 注意：这个方法不能捕获所有的错误；要捕获解码错误，用户必须加载整个图像。 例子：1234567&gt;&gt;&gt;from PIL import Image&gt;&gt;&gt;im01 = Image.open("D:\\Code\\Python\\test\\img\\test01.jpg")&gt;&gt;&gt;im01.verify()没有任何输出，表示图像im01是没有损坏的。]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>PIL库</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取淘宝搜索结果]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[通过python爬虫可以轻松爬取淘宝搜索关键字返回的内容 效果展示： 源码：淘宝网搜索功能受限：由于淘宝设置了要登陆了才能使用搜索功能 so， 下面这份简单的爬虫代码并不会起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CrowTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 解决办法：首先我们需要先在浏览器中登录我们的个人淘宝，然后搜索以书包为例的商品，打开开发者模式（我使用的是chrome）或者按F12 这里我们可以看到我们当前的cookie和user-agent（一般是Mozilla/5.0）（注意：如果没有出现这几个name，点击浏览器刷新就会出现了） 通过增加cookie和user-agent，发现代码正常运行 下面代码中getcookiefromchrome函数为获取cookie 然后在gethtmltext函数中增加cookie和user-agent访问身份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport reimport sqlite3import requestsfrom win32.win32crypt import CryptUnprotectDatadef getcookiefromchrome(): host = '.taobao.com' cookies_str = '' cookiepath=os.environ['LOCALAPPDATA']+r"\Google\Chrome\User Data\Default\Cookies" sql="select host_key,name,encrypted_value from cookies where host_key='%s'" % host with sqlite3.connect(cookiepath) as conn: cu=conn.cursor() cookies=&#123;name:CryptUnprotectData(encrypted_value)[1].decode() for host_key,name,encrypted_value in cu.execute(sql).fetchall()&#125; for key,values in cookies.items(): cookies_str = cookies_str + str(key)+"="+str(values)+';' return cookies_str def getHTMLText(url): cookies = getcookiefromchrome() kv = &#123;'cookie':cookies,'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url, headers=kv, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "" def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("") def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号","价格","商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = input('商品：') depth = int(input('页数：')) start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] print ("正在爬取···") for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList) main() 实测只有先前已经登陆过淘宝页面才能正常运行以上代码（清楚浏览器数据后运行没成功） 问题后续有时间再研究。。。 补充一些效果图吧：]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pymatplotlib库画函数图]]></title>
    <url>%2F2019%2F04%2F27%2Fpymatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib库提供许多函数画静态图以及动态图。 下面展示效果图和源码：demo1: 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltimport numpy as np#author：zzm#time: 2019.4.25s = np.arange(0, np.pi*2, 0.01)def x(s,a,p): return a*np.sin(p*s)def y(s,b,q,t): return b*np.sin(q*s+t)def lisa(a,b,n,t,posit): p = 1 q = n*p plt.subplot(3,3,posit) plt.grid() plt.plot(x(s,a,p),y(s,b,q,t))lisa(1,1,1,0,1)lisa(1,1,1,np.pi/2,2)lisa(1,1,1,1,3)lisa(1,1,2,0,7)lisa(1,1,1,np.pi/2,8)lisa(1,1,1,1,9)plt.savefig('test', dpi = 600)plt.show() demo2: 1234567891011121314151617181920212223242526272829import numpy as np import matplotlib.pyplot as pltfrom matplotlib import animationfig, ax = plt.subplots()x = np.linspace(0, 2*np.pi, 200)y = np.sin(x)l = ax.plot(x, y)dot, = ax.plot([], [], 'ro')def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ldef gen_dot(): for i in np.linspace(0, 2*np.pi, 200): newdot = [i, np.sin(i)] yield newdotdef update_dot(newd): dot.set_data(newd[0], newd[1]) return dot,ani = animation.FuncAnimation(fig, update_dot, frames = gen_dot, interval = 100, init_func=init)ani.save('sin_dot.gif', writer='pillow', fps=30)plt.show() demo3: 12345678910111213141516171819202122232425262728293031import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animationfig = plt.figure(figsize=(6, 6))ax = plt.gca()ax.grid()ln1, = ax.plot([], [], '-', lw=2)ln2, = ax.plot([], [], '-', color='r', lw=2)theta = np.linspace(0, 2*np.pi, 100)r_out = 1r_in = 0.5def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) x_out = [r_out*np.cos(theta[i]) for i in range(len(theta))] y_out = [r_out*np.sin(theta[i]) for i in range(len(theta))] ln1.set_data(x_out, y_out) return ln1,def update(i): x_in = [(r_out-r_in)*np.cos(theta[i])+r_in*np.cos(theta[j]) for j in range(len(theta))] y_in = [(r_out-r_in)*np.sin(theta[i])+r_in*np.sin(theta[j]) for j in range(len(theta))] ln2.set_data(x_in, y_in) return ln2,ani = animation.FuncAnimation(fig, update, range(len(theta)), init_func=init, interval=30)ani.save('roll.gif', writer='pillow', fps=100)plt.show() demo4: 123456789101112131415161718192021222324252627282930313233343536373839404142from math import sin, cosimport numpy as npfrom scipy.integrate import odeintimport matplotlib.pyplot as pltimport matplotlib.animation as animationg = 9.8leng = 1.0def pendulum_equations(w, t, l): th, v = w dth = v dv = - g/l * sin(th) return dth, dvt = np.arange(0, 20, 0.1)track = odeint(pendulum_equations, (1.0, 0), t, args=(leng,))xdata = [leng*sin(track[i, 0]) for i in range(len(track))]ydata = [-leng*cos(track[i, 0]) for i in range(len(track))]figure, ax = plt.subplots()ax.grid()line, = ax.plot([], [], 'H-', color='darkred', lw=2)time_template = 'time = %.1fs'time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)def init(): ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) time_text.set_text('') return line, time_textdef update(i): newx = [0, xdata[i]] newy = [0, ydata[i]] line.set_data(newx, newy) time_text.set_text(time_template %(0.1*i)) return line, time_textani = animation.FuncAnimation(figure, update, range(1, len(xdata)), init_func=init, interval=50)ani.save('f2.gif', writer='pillow', fps=100)plt.show() demo5: 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots()xdata, ydata = [], []ln, = ax.plot([], [], 'r-', animated=False) #,表示创建tuple类def init(): ax.set_xlim(0, 2*np.pi) ax.set_ylim(-1, 1) return ln,def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)ani.save('f1.gif', writer='pillow', fps=30)plt.show() demo6:1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation#author： zzm#time： 2019.4.25#制作李萨如图形动态gif#李萨如图形的轨迹方程：# x = A1cos(wt+β1)# y = A2cos(wt+β2)figure, ax = plt.subplots()xdata, ydata = [], []dot, = ax.plot([], [], 'r-', animated=False)#def x(s):# return np.cos(3*s+np.pi)def y(s): return 4/np.pi/3*np.sin(3*s)+4/np.pi/3*np.sin(3*s)def init(): ax.set_xlim(-np.pi, np.pi) ax.set_ylim(-2, 2) return dot,def update(frame): xdata.append(frame) ydata.append(y(frame)) dot.set_data(xdata, ydata) return dot,photo = FuncAnimation(figure, update, frames=np.linspace(-np.pi,np.pi, 128), init_func=init, blit=True)photo.save('zz2.gif', writer='pillow', fps=30)plt.show()]]></content>
      <categories>
        <category>python</category>
        <category>库的学习</category>
        <category>pymatplotlib库</category>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello！]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello!Welcome to my blog!坐标(Location)： 广州(Guangzhou)职业(Job)： 大学生(College student)博客简介(Blog introduction) ：记录日常~~~ (Record daily work and life happened) 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello! Welcome to my blog!" &lt;&lt; endl; cout &lt;&lt; "坐标(Location)： 广州(Guangzhou)" &lt;&lt; endl; cout &lt;&lt; "职业(Job)： 大学生(College student)" &lt;&lt; endl; cout &lt;&lt; "博客简介(Blog introduction) ：" &lt;&lt; endl; cout &lt;&lt; "记录日常~~~ (Record daily work and life happened)"; return 0;&#125;]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
  </entry>
</search>
